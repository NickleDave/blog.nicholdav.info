[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hoping machine",
    "section": "",
    "text": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024\n\n\n\n\n\n\nmusic\n\n\ntech\n\n\n\nMusic I bought on Bandcamp this year, and why\n\n\n\n\n\nJan 5, 2025\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nDomain-driven software design is a good idea, still\n\n\n\n\n\n\ndomain-driven design\n\n\ncomputer science\n\n\nresearch software engineering\n\n\n\nDomain-driven design might not be a new idea, but you should think about it more anyways\n\n\n\n\n\nJan 2, 2025\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nFour tips for structuring your research group‚Äôs Python packages\n\n\n\n\n\n\nresearch software engineering\n\n\nPython\n\n\n\nHow to structure your Python package so other researchers want to use it\n\n\n\n\n\nDec 26, 2022\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nMake your own academicpages site from scratch with jekyll\n\n\n\n\n\n\nacademia\n\n\n\nInstead of forking academicpages, make it yourself to better understand jekyll\n\n\n\n\n\nMar 16, 2022\n\n\nDavid Nicholson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html",
    "href": "posts/2025-01-02-domain-driven-design/index.html",
    "title": "Domain-driven software design is a good idea, still",
    "section": "",
    "text": "Update 2025-09-24: I broke this post up into two posts, one here and one on the VocalPy developer‚Äôs blog, based on feedback from folks in the US-RSE and pyOpenSci communities: Ben Fulton, Hector Correa, Kris Armeni and Warrick Ball, and Felipe Moreno.\nUpdate 2025-12-23: Revised again.\nIn this post I hope to convince you that you should care about domain-driven design. It falls into the category of ‚Äúme writing about how my thinking has evolved about research and software‚Äù.\nYou might read about domain-driven design and think ‚ÄúI already do this. Why do I need to name it and formalize it?‚Äù I am not claiming this is a radical new idea. What I hope to convince you of is that, sure, domain-driven design is just as obvious as it sounds, but you should be thinking about it more anyways.\nSo: first I‚Äôll introduce domain driven design, then I‚Äôll explain why I think it‚Äôs worth thinking about it more, even if you think it‚Äôs something you already do."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#what-is-domain-driven-design",
    "href": "posts/2025-01-02-domain-driven-design/index.html#what-is-domain-driven-design",
    "title": "Domain-driven software design is a good idea, still",
    "section": "What is domain-driven design?",
    "text": "What is domain-driven design?\nFirst, let me introduce domain-driven design, and tell you why you might care about it. Sometime in 2022-2023, I read Domain-Driven Design by Eric Evans, and I got really excited about it. (You can get it from bookshop.org here, and if you‚Äôre feeling dangerous you can probably find a PDF of it on a random GitHub repository.) I ended up reading it because I had been reading Architecture Patterns with Python, and they mentioned it in the introduction.\nIf you do nothing else, read the first chapter of Evans‚Äô book, where he relates the story of how he worked with some electrical engineers to design software they would use to design printed circuit boards (AKA PCBs).\nAt the beginning, he makes mistakes. He tries to understand their jargon word-for-word. Then he asks them to specify in detail what they think the software should do. Neither of those approaches were ever going to work well. Finally he hits upon the idea of asking them to draw out diagrams of their process and how the software should interact with it. These are simple, rough box and arrow sketches as he shows.\n\n\n\nevans figure 1.2\n\n\nNotice what is happening here: this is not just a developer creating a UML diagram to show to other developers. This is software engineers and domain experts developing a pidgin language together. They use this pidgin to talk about the domain problem they are trying to solve with software.\nIt‚Äôs an interesting story for a couple of reasons. First of all, you have a feeling that he is almost an anthropologist, going into this unfamiliar tribe of electrical engineers so he can learn their culture. I think this is a familiar feeling for anyone who has tried to translate some real-world domain into software, even if it‚Äôs part of a culture they feel like they belong to. Second, you really get a feel for his process.\nIf you have ever gone through the process of designing software for some real-world domain, I bet the story really resonates with you. Or, you know what? I‚Äôll dare to say that, even if you have only ever written nerdy software tools for the domain of other software nerds, you still might find that the story resonates with you. Software engineering is a domain, after all. (I‚Äôll return to this point below.)\nAt this point, you might be thinking, ‚Äúwrite code in terms of your domain, yeah, sure, everybody does that‚Äù. I got really excited reading this stuff, and told people about it at the job I had at the time. I made a big deal of presenting parts of the book, and talking about how we could use this approach for what we were working on. And I got this very underwhelmed response of ‚ÄúYeah, we sort of already do that. Aren‚Äôt you just describing object-oriented programming?‚Äù Yes, but no! I‚Äôll come back to the ‚Äúno, we aren‚Äôt doing that‚Äù below, but first, the yes. We should realize this is what we‚Äôre already doing and be very explicit about it! The domain should be at the front of our mind at all times, and we only should be iterating on the design of our software insofar as it relates to the domain!\nNow, the ‚Äúbut no‚Äù: domain-driven development isn‚Äôt just thinking about the domain. Yes, we all think of the domain when we write our code, more or less subconsciously. But Evans advocates for a specific development process. He says this process is required for his approach to design to work. He sees it as a form of extreme or Agile programming. If you‚Äôre not familiar with those, the important thing to know here that they are more iterative than previous approaches, that focused on ‚Äúelaborate development methodologies that burden projects with useless, static documents and obsessive upfront planning and design‚Äù, as Evans puts it. Instead, he focuses on writing code that has a bare bones implementation he can test right away. ‚ÄúDevelopment is iterative.‚Äù Of course, this is one place where Python, my main programming language, shines. It‚Äôs really easy to iterate interactively in a Jupyter notebook with a bare-bones implementation of your sketch of an API. Of course, later you should do some proper engineering instead of living in Jupyter notebooks, so you don‚Äôt have to worry about someone giving a preachy conference talk that condemns you for your naughty programming practices.\nEvans‚Äô other requirement for the development process is that ‚Äú[d]evelopers and domain experts have a close relationship.‚Äù If you are a researcher who programs, well, hopefully you already have a close relationship with yourself. And with your collaborators and colleagues. This second requirement naturally gives rise to one of the key ideas from the book, that of ubiquitous language. This is what I called a pidgin above. It‚Äôs a language that the domain experts and software developers arrive at together through the iterative process of development. The words in this ubiquitous language correspond to key concepts in the domain that the software needs to capture, the things that developers and domain-experts realize they should focus on, as they iterate. Ubiquitous language ‚Äúembeds domain terminology in the software systems we build‚Äù, as Martin Fowler puts it in this post. It‚Äôs this continous process of developer and domain expert iterating together that really appeals to me."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#domain-driven-design-is-not-new",
    "href": "posts/2025-01-02-domain-driven-design/index.html#domain-driven-design-is-not-new",
    "title": "Domain-driven software design is a good idea, still",
    "section": "Domain-driven design is not new, and you should think about it more anyway",
    "text": "Domain-driven design is not new, and you should think about it more anyway\nOk, so now let me circle back around, talk about why, sure, domain-driven design is not a new idea (as Evans himself acknowledges right at the start of his book), and why you should be doing it, or doing even more of it. This is where I come back to the ‚Äúno‚Äù part of ‚ÄúDo we already do this? Yes and no.‚Äù As you can tell, I‚Äôve gotten this reaction before: ‚Äúso, yeah, we already do that‚Äù.\nIf that‚Äôs so, then show me the doodles! Like Evans‚Äô box-and-arrow diagrams above. Show me your mental model of your domain. Put it in your docs! Let me read it, let me actually see these schematics, even if they are just doodles, it helps me to know how your thought process evolved. All I can see right now is this insurmountable mountain of code. I don‚Äôt even know where the hiking trail starts so that I can scale the mountain! I know that there are examples of people doing this, e.g., in the scientific Python community where I spend most of my time, but I think it‚Äôs fair to say that this is not the norm. (Thank you to Warrick Ball from US-RSE who shared a good example of domain-driven design from his aims3 docs) I don‚Äôt know that I have ever seen diagrams showing how the design evolved, as part of an iterative development process. I can‚Äôt help but feel like that‚Äôs exactly the sort of thing that could help people get up to speed on how the code works.\nJust to make this real concrete, I‚Äôll give one example from my world of scientific Python. With this example, I want to show first of all that, yes, people definitely work this already, even if they don‚Äôt call it domain-driven design. And, second, that we could make this design process easier to find, and use it in a way that makes code easier to understand. My example is: the numpy n-dimensional array, that we‚Äôll call ndarray for short. This is the core abstraction tha makes all of scientific Python possible. How do the developers of NumPy conceive of the ndarray? Of course, if you go to the ‚ÄúGetting Started‚Äù section, you can get a written introduction, arguing for why we need an n-dimensional array in Python, and showing you some code snippets. Great. But I want a drawing. Like the doodles above. A picture is worth a thousand words. So if I make it down to the bottom of that page, I can find a link to the NumPy reference, and there finally if I click on array objects, I can find this picture:\n\nI think a diagram like this would help a beginner understand what an ndarray is!\nAnd I can‚Äôt be the only one, since Nicolas Rougier has written a whole book about going from Python to NumPy, and he starts the book with these kinds of diagrams.\n\n\n\n\n\n\n\n\nDiagram of item layout of NumPy array\n\n\n\n\n\n\n\nDiagram of memory layout of NumPy array\n\n\n\n\n\n\nFigure¬†1: Diagrams from book From Python to NumPy showing ‚Äúanatomy of a NumPy array‚Äù\n\n\n\nSimilarly, the Software Carpentry course Programming with Python uses a diagram to illustrate how numpy.max function works. (If you look up the numpy.ndarray.max method, you‚Äôll be directed to the numpy.max page.)\n\n\n\nDiagram of how the numpy max function works when the argument axis is 0 and when it is 1\n\n\nEvery time I have to remember which axis is which, I find myself wishing the NumPy docs had a diagram like this.\nMore to my point above: I want to know how the design of the ndarray evolved! How did a group of developers come together from packages like numeric and arrive at a new design? What did they recycle, and what did they throw away? If I look at the ‚ÄúUnder-the-hood documentation for developers‚Äù, I don‚Äôt find any of this. Of course you can argue that this might seem like too much detail for developer docs. If I‚Äôm a developer and I‚Äôm just trying to figure out how to subclass ndarray, do I really need to know the whole history of your library? Yet I know this stuff exists, on GitHub issues for example, as part of the design and development process. So maybe it‚Äôs worth keeping a record of how things evolved somewhere in your documentation? And making that more readable with diagrams.\nPlease let me emphasize that I am not trying to call out Numpy here, or make an example of them, or anything like that. I know how much work and how many volunteer hours go into maintaining NumPy, and building the community around it. A lot of those people are my friends from conferences. I just want to give some sort of concrete examples. In their defense, we can notice that NumPy is so widely used that it was easy for me to find these examples. I am just wondering what else we can do as research software engineers to make libraries more approachable. Maybe it would help prevent snarky young kids from writing blog posts like this.\nNot to belabor the point, but I‚Äôll stick in a couple more examples of architecture diagrams from docs that I have noticed since I‚Äôve been revisiting this idea. Two things I want to say here: the first being that, while it‚Äôs good that these diagrams exist, you often have to dig to find them. So, again, I‚Äôm not saying I have a revolutionary idea; I‚Äôm just wondering if we could surface this stuff a little more.\nHere for example is a diagram from the ‚Äúinternals‚Äù section of the dask docs on scheduling, illustrating the two types of schedulers:\n\n\n\ndiagram showing two types of Dask schedulers\n\n\nAnd here is a diagram from the ‚Äúarchitecture‚Äù section of the mlflow docs, illustrating common setups:\n\n\n\ndiagram showing coming setups of mlflow\n\n\nThe second thing I want to say here is: I think you can see these diagrams differently. They show software engineers doing domain-driven design. At the risk of sounding like I‚Äôm preaching that ‚Äúeverything is domain-driven design‚Äù, I‚Äôll say that this looks to me now like software engineers designing for a domain using an ubiquitous language, one spoken by the other engineers they work with, and the engineers that use their libraries. They speak in terms of ‚Äúabstractions‚Äù and ‚Äúarchitectures‚Äù. (This is me returning to the point above about software engineering being a domain.)"
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#reprise-domain-driven-design-is-such-an-old-idea-that-its-in-sicp",
    "href": "posts/2025-01-02-domain-driven-design/index.html#reprise-domain-driven-design-is-such-an-old-idea-that-its-in-sicp",
    "title": "Domain-driven software design is a good idea, still",
    "section": "Reprise: domain-driven design is such an old idea that it‚Äôs in SICP",
    "text": "Reprise: domain-driven design is such an old idea that it‚Äôs in SICP\nLastly, let me reiterate, I know these ideas are not new. I now know for sure they‚Äôve been around longer than Eric Evans‚Äô book, because I have been attempting to read yet another book, Structure and Interpretation of Computer Programs, AKA, SICP. I ended up finding domain-driven design in SICP, and having to admit to myself that, yeah, this idea has been around forever. When I got to chapters 2 and 3, there I saw that we were talking about data abstraction and designing programs for modeling. Sound familiar? Let me quote you this bit from chapter 3:\n\nOne powerful design strategy, which is particularly appropriate to the construction of programs for modeling physical systems, is to base the structure of our programs on the structure of the system being modeled. For each object in the system, we construct a corresponding computational object. For each system action, we define a symbolic operation in our computational model. Our hope in using this strategy is that extending the model to accommodate new objects or new actions will require no strategic changes to the program, only the addition of the new symbolic analogs of those objects or actions. If we have been successful in our system organization, then to add a new feature or debug an old one we will have to work on only a localized part of the system.\n\nWell there it is, domain-driven design in a nutshell.\nI hate to end on an appeal to authority, but I feel like, if a book as venerable and time-honored as SICP talks about domain-driven design, if the authors think it‚Äôs worth discussing in the introductory sections of their chapters, then it must be an idea worth keeping in mind. (Such is the state of computer science that I am calling a book that‚Äôs less than half a century old ‚Äútime-honored‚Äù.) I hope I‚Äôve convinced you to think about domain-driven design just a little more."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#addendum",
    "href": "posts/2025-01-02-domain-driven-design/index.html#addendum",
    "title": "Domain-driven software design is a good idea, still",
    "section": "Addendum",
    "text": "Addendum\nI wrote a follow-up post related to what I‚Äôm learning from SICP: ‚ÄúHave a working model when you code‚Äù. I broke that off into another post to make extra sure I don‚Äôt sound like a rabid revolutionary claiming that everything is domain-driven design. I‚Äôm afraid I am tiptoeing towards a breakaway sect of programmers here.\nBut I have to say that thinking about domain-driven design has also got me seeing overlap with ideas like programming as theory building, and domain-specific languages as an alternative to magical, god-like AI ‚Äúagents‚Äù that do all the intellectual heavy lifting for software developers (and anyone else who does any kind of creative thinking for a living). See this quote from the introduction to ‚ÄúA Small Matter of Programming‚Äù (the book I just linked to, that considers task-specific languages, among other things):\n\n(Thank you to Alistair Davidson who I saw post about this book on Bluesky, I‚Äôm recycling their screenshot and alt text.) I think that ideas about software as the output of a human-driven, theory-based process put the lie to the notion that Large Language Model-driven development will end software engineering as we know it sometime soon. LLMs can‚Äôt think, they can‚Äôt theorize, no matter how many names you steal from cognitive science to give to the underlying math. Yes, as a (lapsed) cognitive scientist, I think ‚Äúchain of thought reasoning‚Äù is an offensive name for what is essentially Viterbi decoding with delusions of grandeur. But I‚Äôll save those thoughts for yet another blog post."
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "",
    "text": "Update 2025-09-24: I edited this down to make all the same points without listing literally almost all the music I bought on Bandcamp last year üòÖ\nIn this post I‚Äôm sharing music I bought on Bandcamp in 2024. I‚Äôll also say a little bit about the interaction of music and the tech industry in general: apps like Spotify, Bandcamp, and YouTube; how they affect artists and how they affect our listening habits. I‚Äôve working on a couple follow-up posts. Those are about how I feel like we‚Äôre getting close to having the tools for musicians and listeners to reclaim ownership of their music. So consider this post a prelude to those.\nEvery December, Spotify rewards us for submitting to their algorithm by giving us our Spotify Wrapped. Their Wrapped tells us which artist we spent the most time with, what song topped our playlists, how many minutes we listened.\nI barely use Spotify. My Wrapped was basically ‚ÄúYou listened to Tame Impala Radio 10 times in August‚Äù.\nI just got into Tame Impala, don‚Äôt judge me. You can see my fifth most listened-to song was a song that I listened to maybe twice, from a French Canadian artist that my friend Alex introduced me to (that‚Äôs foreshadowing for later).\nBut I love to see people share their Wrapped on Bluesky and Twitter, especially if ironic. ‚ÄúYes, I am in the top 0.01% of Gwar fans.‚Äù\nI want my own Wrapped! I want to tell a story about what I did this year, kind of like a tech blogger making a listicle of their annual achievements. But I want to receive it passively from the app I listen to music on, instead of me writing a blog post. (Wait a second.)\nThankfully, my good friend Alex Chabot-Leclerc knows that I buy a lot of music through Bandcamp.\nAnd that‚Äôs why he shared this cool blog post with me from Tom MacWright, on how to generate a Bandcamp Wrapped, with an app that MacWright has on val.town:\nhttps://macwright.com/2024/12/06/bandcamp-wrapped.html.\nThe actual app on val.town is here: https://tmcw-bandcampwrapped.web.val.run/\nI think Alex is a big fan of MacWright‚Äôs work. And like me, Alex is really into music, and posts about it weekly on his blog: https://alexchabot.net/categories/music/\nHe shares Spotify links and playlists, and that works great (I will begrudgingly admit that there are some good things about tech).\nBut for those of us that buy a lot of music on Bandcamp, we can now generate our own Wrapped, thanks to Mac."
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#is-bandcamp-itself-wrapped",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#is-bandcamp-itself-wrapped",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "Is Bandcamp Itself Wrapped?",
    "text": "Is Bandcamp Itself Wrapped?\nIn his Bandcamp Wrapped blog post, MacWright links to his own previous writing about his ‚Äúprepper-style music hoarding‚Äù. To quote him, ‚ÄúI don‚Äôt believe that any technology company in the music industry will survive in the long term.‚Äù You should read what he has to say, but let me tell why I buy a lot of music on Bandcamp, since I‚Äôm here writing a whole post about it.\nI am a huge music fan. I wanted to be a musician, once. So I am painfully aware that the tech industry I now work in has really changed how musicians make money. It used to be that record companies could support a relatively broad base of musicians, as long as those musicians helped them sell enough sounds etched into highly processed dinosaur bones (i.e., records). Now we have replaced that system with a new one, where tech overlords support a much narrower base of musicians, almost by accident, since they pay only thousandths of a penny every time a song gets streamed. I think somebody wrote a pretty good song about it once.\n\n\n(You can‚Äôt read the rest of this blog post until you sit through the whole song. My blog, my rules üòé)\nOf course the right fix for this is to not actually change the system, but instead to make each person feel like they alone are personally responsible for fixing everything. And that is why, whenever I can, I pay for music through Bandcamp. Individualism! Exceptionalism! Americanism! The Bandcamp business model lets me put my money where my mouth is, because it gives artists and labels a lot of control over how they sell music: what prices they set, what merchandise they sell, and so on. This seemed like a good way to vote with my dollars for an alternative to streaming platforms like Spotify. Until Bandcamp was acquired by Epic Games, and then by Songtradr, who layed off half the staff. Perhaps not surprisingly, this was around the same time that Bandcamp workers were trying to unionize. So much for ‚Äúchampioning independent artists‚Äù. So much for me personally fixing everything.\nOk, the angry tech bros of the broligarchy are telling themselves I‚Äôm just virtue-signaling with this whole little section about how I basically deserve a Nobel prize for the amount of money I‚Äôve given to artists through Bandcamp. The last thing I‚Äôll say, before I actually write about music, is that I have seen a couple of attempts to build worker-owned platforms. In principle, I am totally in favor of this. We do not need our feudal tech overlords, and the sooner we realize it the better. But in practice, there‚Äôs some complicated economics game theory going on when you have multiple companies, each running on a shoelace budget, all trying to replace the platform run by the tech barons, who have infinite money to fend them off. Still it‚Äôs worth knowing about these efforts. Someone who is smarter than me made this great website that sums up what‚Äôs been done: https://bandcampalternative.com/"
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#more-like-youtube-wrapped-2020-2024",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#more-like-youtube-wrapped-2020-2024",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "More like Youtube Wrapped 2020-2024",
    "text": "More like Youtube Wrapped 2020-2024\nI will mostly shut up about tech now, and mainly write about music.\nI did as MacWright‚Äôs tool instructs, copying and pasting my Bandcamp purchases from 2024. That gave me a big list in HTML. Instead of just dumping the output here, I decided to write about the music I‚Äôve been into over the last year, and how I found it. But it turns out this blog post will be way too long if I write about all the music I bought on Bandcamp this year ([virtue signaling intensifies]). So I‚Äôll talk about something more interesting: how do I replace Spotify‚Äôs recommendations? I can pay artists directly, I can make my own Spotify wrapped, but how do I find new music? It turns out, mostly YouTube, but also recommendations from friends. Let‚Äôs talk about each in turn.\n\nI was radicalized by YouTube ambient playlists\nI have been into ambient for a while. Like a lot of people, I was unwittingly turned on to Japanese ambient during the pandemic, thanks to the YouTube algorithm. See this article on ars technica: https://arstechnica.com/gaming/2020/11/how-old-ambient-japanese-music-became-a-smash-hit-on-youtube/ (I like a lot of the related music namechecked in this article, that was also mysteriously promoted by the YouTube algorithm, like 1979 from Deru, Mort Garson‚Äôs Plantasia, and An Empty Bliss Beyond this World by the Caretaker)\nLooking back over this year, The Algorithm has continued to turn me on to a lot of other ambient, but more into the genre of Space Music. Somehow this sci-fi ambient fits with the rest of my media diet: I played a lot of post-apocalpytic roguelike Caves of Qud this year and I re-read the first book of the post-apocalpytic Southern Reach Trilogy.\n\n\nUK ambient\n\n\nNACHT MUSIK by Steve Brenner\n\n\nDARK HOUR Brenner/Gulch by STEVE BRENNER\n\n\nS I G N A L S by STEVE BRENNER\n\n\nTwelve Dimensional World by Tim Stebbing\n\n\nOrbiter by Tim Stebbing\n\n\nBoth Steve Brenner and Tim Stebbing I think are UK artists who got their start in the ~70s. I found them through YouTube channels like Sounds of the Dawn, here and here. Side note: Brenner has directly sent me a (brief!) email every time I‚Äôve purchased from him. This is the kind of personal touch you don‚Äôt get when you stream music through a Platform.\n\n\nAmerican Primitive ambient\nOk, there‚Äôs only one group in this category, the Nightcrawlers, but I love them, and I wish I could pay them more for all of their music. I don‚Äôt know if they already have their own microgenre but I‚Äôm going to call it ‚ÄúAmerican Primitive ambient‚Äù.\n\n\nThe Biophonic Boombox Recordings by The Nightcrawlers\n\n\nI found them through this channel: https://www.youtube.com/watch?v=qkmsWKKPVvo But as that person kindly pointed out, there‚Äôs actually another channel with a whole playlist of just the Nightcrawlers.\n\n\nWhat I really love about their albums are the art, clearly made on some 80s graphic design software like Printshop, but somehow managing to have a mysticisim at the same time.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThey have a mysticisim in the same way that I think Robert Pollard‚Äôs lyrics about UFOs and his collage album covers are, at their best, mystical.\n\n\n(I know, as of that last sentence I‚Äôm really blurring the line between tech blog and annoying album review guys on YouTube. Bro, I contain multitudes.)\n\n\nModular?\nOne last bit of ambient music, two groups that I will lump into another totally-made up microgenre I‚Äôll call ‚Äú80s american ambient‚Äù, since there‚Äôs no overt themes of space per se.\n\nYoung Scientist\nThe first group is named Young Scientist, and with a name like that of course I have to like them. I‚Äôm no longer so young, but I do feel like they really have made scientist soundtrack music, that conjures up late hours in the lab. Yes, I found them through YouTube.\n\n\nOver Low Trees‚Ä¶ by Young Scientist\n\n\nResults, Not Answers by Young Scientist\n\n\n\n\nSines of Exquisite Pleasure\nThe second group is Sines of Modular Pleasure. Again, yes, I found them through YouTube.\nThere‚Äôs some question of whether they are even ‚Äúreal‚Äù, in the sense of really old, or whether it‚Äôs more of a tribute group making music in the present day. Check out this maniac‚Äôs blog post: https://ivandsm.github.io/2022/12/04/on-sines-of-exquisite-pleasure.html (Maniac in a good way, thank you for your work, whoever you are.) Based on their latest release, I think they are indeed more of an homage. It still works for me, and I would still lump it into this category of sounding like ‚ÄúAmerican suburban guys who wanted to be Brian Eno or Tangerine Dream but had to re-invent the genre from scratch‚Äù.\n\n\nAlaska by Sines of Exquisite Pleasure\n\n\nStudies in Luminescence by Sines of Exquisite Pleasure\n\n\nModular Systems by Sines of Exquisite Pleasure\n\n\nMusic for Hospitals by Sines of Exquisite Pleasure\n\n\n\n\n\nHome\nOk, so we are definitely at the point where, if I list all the music I bought on Bandcamp this year, this blog post would put you to sleep, if it‚Äôs not already.\nBut I can‚Äôt resist sharing one more artist I found through YouTube this year, this time as the first song on this random ‚Äúmix‚Äù video that features a mecha-Bart Simpson as the image with a trippy bad VR background.\n\n\nYou‚Äôre telling me that you do not feel goosebumps all over your body, as if a your soul became a laser beam shooting out of God‚Äôs forehead, at the very moment you hear that first song, with the mecha-Bart and the cyberpunk background undulating behind? You, sir, have no soul. (Or madam. Or ma-them. However you prefer to be addressed.)\nTurns out all their other shit is really good too.\n\n\nFalling Into Place by HOME\n\n\nResting State by HOME\n\n\nBefore The Night by HOME\n\n\n\n\nMy Alex Chabot-Leclerc Wrapped 2024\nThe other way I find music is through friends of course. Since my friend Alex inspired this post, I would be remiss if I didn‚Äôt include the music I bought from his home of Canada this year. I promise I have at least one other friend, but I also promised I was trying to keep this post somewhat short. So, let‚Äôs just talk about what Alex recommended to me.\n\n\nTop Minou by Bleu Jeans Bleu\n\n\nL‚Äôappartement by ludovic alarie\n\n\n√Ä demain peut-√™tre by Galaxie\n\n\nAqualudes by Am√©lie Fortin\n\n\nHe introduced me to Bleu Jeans Bleu a couple of years ago. Primo quality rock/pop with a distinctly Quebecois flair. Alex told me one of their songs perfectly captures the feeling of being in Quebec for him. You might mistake them for a novelty group, ironically parodying\nSee for example,\n\n\nThe L‚Äôappartment album I found while in Maine for the NMAC 2024 conference. I was sitting in the parking lot of the hotel the conference was at, and this song came on the radio, on this French Canadian station I had managed to pick up. It was just a very nice vibe, made even more nice by the slight patina of static from the almost out of range station. I loved the song so much I ran inside to google and try and figure out what station it must be, so I could see if they had a playlist. Like a total weirdo, I was even asking people at the conference I knew who happend to be from Canada if they knew of the stations. No, what is wrong with you. I found the station anyway, and they did have a playlist.\nI liked the band so much I had to ask Alex if he knew of them; he did not, but the name rang a bell, and in fact this musician is the son of another musician Alex is familiar with. Not surprisingly, Alex suggested some other musicians in the same vein, like Amelie Fortin. And then later in the year he happened to recommend Galaxie, that definitely hit that alternative rock spot in a way I haven‚Äôt heard in a while."
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#next-time",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#next-time",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "Next time",
    "text": "Next time\nIf you made it through all this music, thank you for your attention. As soon as I add those other posts about reclaiming ownership of music, I will link them here."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "",
    "text": "Update 2025-09-24: Fixed how a numbered list was formatted.\nUpdate 2025-01-08: I switched to quarto, but I refuse to write a blog post about it.\nUpdate 2022-12-17: I added a home page and a blog to my site, so I no longer use a set up exactly like the academicpages theme, but I‚Äôm leaving this post up to document the process (and because it‚Äôs currently my only post üò≠)\nIn this post I document the process I went through to set up a peronsal web site with a structure similar to the academicpages theme used by many academics (https://academicpages.github.io/). I‚Äôm writing the post for my future self, and for you if you want to do the same."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô",
    "text": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô\nHere‚Äôs the summary version first, so you know what you‚Äôre getting into:\n\nset up a jekyll development environment\nmake the landing page be your about page\nmake the sidebar show your profile with links\nadd links to publications, talks, etc., in the nav bar at the top of the page"
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#why-would-you-bother",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#why-would-you-bother",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Why would you bother?",
    "text": "Why would you bother?\nI wanted a site similar in style to academicpages (https://academicpages.github.io/), with links in the sidebar to Google Scholar, OrcID, etc., and the ability to use jekyll‚Äôs ‚Äúcollections‚Äù feature to easily organize publications, talks and teaching. But I also wanted the flexibility to change themes, which is not easy to do with academicpages.\nIf you‚Äôre like me, and you mainly write code in Python, you might naturally use a static site generator written in Python (as I did for a while, see next section). Using jekyll, that‚Äôs written in Ruby, might feel like a big jump‚Äì the big pain point in switching languages is often getting familiar with their tooling. As a Pythonista, of course I want to support Python libraries, and some of the static site generators like pelican are battle tested with themes that are very versatile, like their version of bootstrap. But somehow minimal-mistakes and other jekyll themes just look better to my (untrained) eye.\nAnd as a programmar and developer, it might be a fun exercise in using libraries in a language besides Python. It‚Äôs interesting to experience the tooling in the ecosystems of other programming languages."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#how-did-we-get-here",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#how-did-we-get-here",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "How did we get here?",
    "text": "How did we get here?\nI‚Äôve had a personal web page for sometime that I set up with pelican, a static web page generator in Python. Basically I adopted my approach from the one Jake Vanderplas took for his ‚Äúpythonic perambulations‚Äù blog. However I wasn‚Äôt happy with how my page looked (which has nothing to do with Jake Vanderplas, and everything to do with my moribund graphic design and css/html skillz). And it was time to update my site anyway. Recently I noticed a collaborator had set up their own personal site using the excellent academicpages repository, developed by Stuart Geiger. academicpages is great if you are trying to survive in academia and you don‚Äôt have time to bother learning how to use a static site generator. With academicpages you just want to follow a couple steps to add your own content to some existing template, to easily get a site.\nSome background: academicpages is a fork of minimal-mistakes, a very popular theme for the jekyll library. jekyyl is a static site generator written in the ruby programming language. You can think of it as analogous to pelican in Python (or Ruby developers might tell me that pelican is analgous to jekyll). One advantage of using jekyll is that GitHub really likes jekyll, letting developers easily create web pages for themselves or documentation for their projects through the GitHub Pages service. And it‚Äôs free, another plus for academics. Stuart modified the minimal-mistakes theme in such a way that other academics could simply fork its repo on GitHub and use the web interface to add their own content, without needing to know how to use jekyll or how to use any developer tools like git.\nSo I knew I wanted a site like academicpages, but I also knew there were things I wanted to modify, such as the theme / template. There‚Äôs little documentation in the academicpages guide about what changes were made to the minimal-mistakes theme, and why. How did Stuart evolve the template from your standard jekyll minimal blog page to a very specific set-up for academics? Unique features of academicpages include that it lands on the about page and shows a profile in the sidebar with links to academia specific sites, and includes tabs like ‚Äúpublications‚Äù, ‚Äútalks‚Äù, etc.? I tried looking at the git commit history but couldn‚Äôt piece it together. I figured there couldn‚Äôt be too too many steps to setting up a similar site on my own."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages-1",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages-1",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô",
    "text": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô\nAgain, here‚Äôs the outline of what we‚Äôre going to do: 1. set up a jekyll development environment 2. make the landing page be your about page 3. make the sidebar show your profile with links 4. add links to publications, talks, etc., in the nav bar at the top of the page\n\nSetting up a development environment\nThis is a thing that might be new to academics not familiar with software engineering, but the jekyll and ruby devs have worked really hard to make it easy.\n\nset up a basic environment for working with jekyll\n\ntheir quickstart is here: https://jekyllrb.com/docs/\nI‚Äôm on PopOS, a Linux distribution similar to Ubuntu, and I use oh-my-zsh, so I followed these instructions: https://jekyllrb.com/docs/installation/ubuntu/ except I changed .bashrc to .zshrc\n\nthen I followed the directions for managing dependencies with bundler so that I could install the minimal-mistakes template as a gem instead of forking their repo and modifying it\n\nhttps://jekyllrb.com/tutorials/using-jekyll-with-bundler\n\n\n\n\nMaking the ‚Äúlanding page‚Äù be your ‚Äúabout‚Äù page\nThis is the first thing that‚Äôs specific to our site design.\n\nuse the redirect plugin so that the site lands on ‚Äúabout‚Äù\nadd an about.md ‚Äì make sure you copy the YAML front matter from academicpages\nmake sure _config.yml specifies defaults for pages so that your theme gets applied to this about.md file\n\nI copied the #defaults section from the academicpages _config.yml\n\n\n\n\nMaking the sidebar show your profile, with links\nNow we‚Äôre cooking with academicpages gas! Or something\n\nto make the author profile in the sidebar render all the links that are in academicpages but not in minimal-mistakes, i.e.¬†academia specific things like a Google Scholar page, ORCID profile, etc., you‚Äôll need to add an author-profile.html in an _includes directory. Basically I copied the author-profile.html from minimal-mistakes and then added the relevant if-then statements in the author-links section.\nfor things like an author pic, I added them in assets/images/ ‚Äì I think this is consider ‚Äúidiomatic Jekyll‚Äù even though the academicpages repo just has an images folder in its root. Doesn‚Äôt matter too much as long as you specify the correct relative path in your _config.yml\n\n\n\nAdding links to publications, talks, etc., in the masthead nav bar\nUnique to academicpages are the links in the navigation bar at the top of the page to pages with lists of publications, talks, and so on.\nIf you want the same thing, there‚Äôs two things you‚Äôll need to do: 1. you‚Äôll need to copy the ‚Äònavigation.yml‚Äô file from academicpages, placing it in a data/ subfolder in your project root, and modify it as you see fit. 2. add two related sections in your _config.yml: + a ‚Äòcollections‚Äô section, like this one in the academicpages _config.yml. + and corresponding keys in your defaults section as shown here in the academicpages _config.yml.\nThis is explained very briefly in the about.md of academicpages but here‚Äôs a quick explainer of how it all works. minimal-mistakes lets you add links to the masthead by supplying a file called navigation.yml. This is a standard approach in jekyll. There are other uses for data files. What‚Äôs specific to minimal-mistakes is that you add these links to the nav bar by specifying a main key in navigation.yml, as described here: https://mmistakes.github.io/minimal-mistakes/docs/navigation/. In the case of academicpages, the links have the names of the specific sections in the navigation.yml with the keys ‚Äúpublications‚Äù, ‚Äútalks‚Äù, etc."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#coda-publishing-etc.",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#coda-publishing-etc.",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Coda: publishing, etc.",
    "text": "Coda: publishing, etc.\nAfter making the changes just described, I had a site with a structure similar to academicpages.\nTo actually publish the site, I still use a workflow similar to what Jake Vanderplas uses for his blog: https://github.com/jakevdp/jakevdp.github.io-source This centers around a Makefile with commands for build and serve.\nThe key thing that makes it easy to publish to Github Pages is to use the ghp-import package, as suggested by the pelican docs: https://docs.getpelican.com/en/latest/tips.html#project-pages. Of course, jekyll gets special treatment on GitHub so it‚Äôs kind of overkill, but I still like having a separate repo that I just push the .html and .css files to without thinking about it.\nSo this is how I have my site set up now! Stay tuned for it to change suddenly, because as a developer I love to spend hours farting around with tools that let me avoid real work. I‚Äôll keep this post up for posterity anyway."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "",
    "text": "Update 2025-09-22: Made some small tweaks to language, but didn‚Äôt hate what I wrote as much as I thought.\nUpdate 2025-01-08:\nI think this post gives better advice overall on designing a Python library API:\nhttps://benhoyt.com/writings/python-api-design/\nYou should read that one first, then come back and read this one for some examples of what not to do.\nThis is one of those petulant posts from someone who writes software. A post from one of those people that describes some library they wrote as ‚Äúopinionated‚Äù, as if the rest of us have been living in fear of expressing our opinions through software.\nSo, sorry in advance. But I want to talk about some things I see a lot in Python packages shared by research groups.\nAt the highest level, there‚Äôs two things I see: one, researchers name their modules in a way that might make sense when you‚Äôre writing your own code, but can seem very verbose or non-intuitive when you are someone else on the outside reading or using that code. Two, I see a lot of code that doesn‚Äôt structure itself in a way that makes it easier for people to read it and to use it. And you‚Äôre sharing your code because you want people to use it, right?\nI think a lot of packages from research labs end up this way in part because researchers don‚Äôt have a good mental model of the mapping from their written code to the package they import. In other words, they don‚Äôt have a clear picture of how Python translates the directory structure of their code and its internal import statements into a package name with modules that can be accessed with the dot operator, like so: package.subpackage.module.function.\nTo use more technical terms, the code does not fully leverage the fact that Python treats modules as namespaces. Namespaces are a way of collecting the objects like functions and classes that we define in code into (named) groups. (Some other people that teach Python to scientists also seem to think it‚Äôs worth knowing how namespaces relate to imports and modules, since they wrote this page.) If I may invoke the holy sayings of the revered masters, ‚Äúnamespaces are a honking great idea‚Äù. To a wizened software engineer, that phrase from the Zen of Python might sound like Python is patting itself on the back for something that basically every modern language does. But for many researchers that are getting their first experience designing a software library, it might seem surprising that I‚Äôm drawing a connection between the pile of files that constitues their code and an abstraction from computer science. If it sounds surprising to you, maybe it‚Äôs because you don‚Äôt (yet) have a good concept map of how namespaces relate to naming your modules and structuring your package.\nSo let me tell you a little bit about that, and how you can build on it to make your code much more accessible. I don‚Äôt claim to have a perfect mental model of Python packages, but at least I have fought enough with my own code, and read enough of others peoples‚Äô code, that I think I can say something useful here. This post contains some things I‚Äôve learned the hard way, to hopefully save you from repeating the mistakes of past me.\nI‚Äôve boiled it down to four tips, that I‚Äôll explain in more detail below.\nHere‚Äôs the high-level version:\nOf course, it goes without saying that these are absolute rules that came to me in a dream where Guido Van Rossum emerged from a burning bush and handed them to me on a freshly-minted PEP. As such, you should never violate them for any reason, unless you feel like it. (Those last two sentences should be written in the sarcasm font.) More seriously, you could call these rules, but there are sometimes good reasons to not follow them to the letter, like we‚Äôll see below.\nOne other thing to say before we get started: I will use some examples here inspired by real life, but namespaces have been changed to protect the innocent. I promise my goal here is not to name shame, but instead to help you make your code as accessible as possible. I also want to note this is not meant to be a whole tutorial, just some pointers on how to pick module names and how to structure your package in a way that makes your code more immediately accessible and more readable. For an introductory tutorial to packages and modules, please see https://realpython.com/python-modules-packages/."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#an-example-of-what-not-to-do",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#an-example-of-what-not-to-do",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "An example of what not to do",
    "text": "An example of what not to do\nHere‚Äôs the scenario: You are really into sharing your research code written in Python. Great! Sharing code just makes sense to you. Your lab is getting on board with this too. You made a GitHub organization for the research group (instead of making an individual profile with the lab name! Please don‚Äôt do that, and make an org page instead, so we can see who‚Äôs in your group and understand who contributes what! For when I want to write you an email thanking you for your work, or ask you to collaborate, or figure out who I want to hire away from academia into the private sector üòà).\nNow everybody in the lab is forking their repos to that org, so you can collaborate and all rely on the same version of the same code. I go to your lab‚Äôs org page and check out one of the repos, and I see something like this.\nelectroymyographytoolkit\n‚îú‚îÄ‚îÄ emg_load_inchan_data_four_channelinkls.py\n‚îú‚îÄ‚îÄ emg_main.py\n‚îú‚îÄ‚îÄ emg_simulate.py\n‚îú‚îÄ‚îÄ emg_solver.py\n‚îú‚îÄ‚îÄ emg_utils.py\n‚îî‚îÄ‚îÄ __init__.py\n\nIn the words of a wise man:\n\nOh No Baby! What Is You Doin???\n\n ‚Äî nicknpattiwhack_"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#what-you-should-do-instead",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#what-you-should-do-instead",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "What you should do instead",
    "text": "What you should do instead\nPlease! Help as many people as possible actually use your code by avoiding naming and package structures like that! Instead you want something like this:\nemgtoolkit\n‚îú‚îÄ‚îÄ load.py\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ simulate.py\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ brute_force.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entropy.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gibson.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ random_walk.py\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shannon.py\n‚îú‚îÄ‚îÄ timestamp.py\n‚îî‚îÄ‚îÄ __init__.py\nThe changes I made above follow the aforementioned four tips. Here‚Äôs they are again, the short version of what you want to do:\n\nGive your packages and modules terse, single-word names whenever possible.\nImport modules internally, instead of importing everything from modules. (You can‚Äôt see this directly in the example above, but I‚Äôll show it below.)\nMake use of sub-packages.\nPrefer modules with very specific names containing single functions over modules with very general names like utils, helpers, or support that contain many functions.\n\nAll of these rules help you make code written with your package more readable from the outside, when someone else uses it from a script. Rules 2,3, and 4 in particular can also help make your code more readable from the inside, when you revisit it after you spent six months in the lab fighting with weird noise from your electrophysiology rig or an IHC protocol or whatever it is that scientists do, I don‚Äôt remember anymore ([laughs in post-academic])."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.pkg_module",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.pkg_module",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Please don‚Äôt name your modules package.pkg_module",
    "text": "Please don‚Äôt name your modules package.pkg_module\nOkay, I will briefly, just for one paragraph, get really ‚Äúopinionated‚Äù. I am not yelling at you. I‚Äôm yelling with you, from the perspective of you as a future user and reader of your own code. (Borrowing a concept from physics while simultaneously breaking its laws, we change our frame of reference and do some time travel so that what you named your modules is no longer a problem for ‚Äúfuture you‚Äù to solve.)\nHere‚Äôs our example package layout again:\nelectroymyographytoolkit\n‚îú‚îÄ‚îÄ emg_load_inchan_data_four_channelinkls.py\n‚îú‚îÄ‚îÄ emg_main.py\n‚îú‚îÄ‚îÄ emg_simulate.py\n‚îú‚îÄ‚îÄ emg_solver.py\n‚îú‚îÄ‚îÄ emg_utils.py\n‚îî‚îÄ‚îÄ __init__.py\n\nyelling:\nLook at this. What is this?! No one wants to type out package.pkg_solver! Why are you making me redundantly type the package name again after I just typed it? Only instead you‚Äôre making me remember and type some abbreviated version of the package name that you dropped some vowels from arbitrarily? And, and you‚Äôre making me type an underscore, that my hand has to go find the shift key for! Every time!!! Yes I know that tab complete exists! This is still too much typing!!! Why do you hate me?\nMore calmly:\nThat might seem like a weirdly specific example to you, but I have seen naming schemes like this more than once (hence, this post). I really do think it has something to do with the way other researchers are thinking about code while writing it and when importing it. They want to import a module from their package and know where it came from, so they put the package name in the module name. I guess? ü§∑ Instead of doing anything like that, just name your package and modules something terse from the get-go, like\nemgtoolkit\n‚îú‚îÄ‚îÄ load.py\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ simulate.py\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ brute_force.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entropy.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gibson.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ random_walk.py\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shannon.py\n‚îú‚îÄ‚îÄ timestamp.py\n‚îî‚îÄ‚îÄ __init__.py\nNow in your scripts you can write out the whole package name, while at the same time having it be more succinct and clear what part of the package‚Äôs namespace you‚Äôre referring to. E.g., emgtoolkit.simulate instead of electromyographytoolkit.emg_simulate. You might have noticed some other things changed in the names, too. Those changes relate to the other tips, that I‚Äôll say more about below."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.incredibly_long_technical_name",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.incredibly_long_technical_name",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Please don‚Äôt name your modules package.incredibly_long_technical_name",
    "text": "Please don‚Äôt name your modules package.incredibly_long_technical_name\nThere is also an even more extreme form of verbose module names, that takes the form of:\npkg/\n  incredibly_long_technical_name_or_specific_task\nSometimes this is justified, if it‚Äôs the core functionality of your package and you really need to clearly communicate to everyone in the universe what the package does. E.g., sklearn.model_selection has a very specific meaning, and it‚Äôs hard to capture with an abbreviation, and the library is trying to capture basically several sub-fields of machine learning within this sub-package. I am okay with tab-completing this name just so it‚Äôs clear to all of us what the heck we‚Äôre doing. But pkg.preprocessing_electrophysiological_data is not a great name. Especially if your package only deals with electrophysiological data. You can just say pkg.preprocess, it‚Äôs fine.\n\nInstead, make module names general, and move specifics to function names\nOften these really long module names can be a very specific thing you need to do. Here again you can make things more terse by moving the more specific part to a function name, while keeping the more general part as a module name. For example, instead of\nelectroymyographytoolkit\n‚îú‚îÄ‚îÄ emg_load_inchan_data_four_channels.py\nname the module load, and name a function in that module inchan_data_four_channels, so that you can type out:\n&gt;&gt;&gt; emgtoolkit.load.inchan_data_four_channels()\nYour intention is still obvious. But you rely on attribute access to make that intention clear, while simultaneously more succinct. This also means you have left yourself room later to add other load functions in your module, like\n&gt;&gt;&gt; emgtoolkit.load.inchan_data_accelerometer_channel()\nor whatever. Trust me, there will be a later. Leave space in your namespace."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#import-modules-not-functions-and-classes-for-readability",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#import-modules-not-functions-and-classes-for-readability",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Import modules, not functions and classes, for readability",
    "text": "Import modules, not functions and classes, for readability\nThis is less about naming and more about importing, but it‚Äôs related because I feel like this same anti-pattern arises from someone not understanding what it is that package structure gives you. It gives you a logical grouping that‚Äôs readable not just from the outside but also from the inside. Let me explain.\nI often see something like this in an internal module:\n# inside main.py\nfrom pkg_solver import (\n    EntropySolver,\n    ShannonSolver,\n    GibsonSolver,\n    ...\n    # 10 more lines of class imports from a single module (!)\n    BruteForceSolver,\n    RandomWalkSolver\n)\nLet‚Äôs say this is in emgtoolkit/main.py. Going back to the overall goal of this post, let‚Äôs think about how the import above will affect the namespace of your package, as seen from the outside. if I am using your package, one of the first things I‚Äôm going to do is inspect the content of emgtoolkit.main, e.g.¬†by running dir(emgtoolkit.main) in a Python REPL, since that name signals to me very loudly that you think of this as its main interface or API. With an import statement like the one above, when I tab complete while working with this module, I am going to be faced with a wall of Solver classes that obscures the true function of the module. This is not the solver module! That‚Äôs some other module! If this is a high-level module that you expect me to access as a user, then please avoid polluting it with all these names. One of the ways you can do this is by making use of sub-packages, as I‚Äôll talk about below.\nI want to make a second point here, that is less about making external use of your code readable, and more about making it readable internally, within the code base. I know that right now while you are hacking on the code, you feel like you have all the low-level context about what all the moving parts are doing. But if you want to make life easier for yourself six months from now, and easier for everyone else that has to use your code, write in a way that surfaces that context. Write in a way that makes it much more obvious where all the functions and classes come from, leveraging the logical grouping that you spent so much time boiling down into concise module names.\nPlease, for your future self and everyone else, make the code readable by importing just the module 1, and then referring to those classes (or function or whatever you‚Äôre referring to) via attribute access, i.e.¬†with a dot, like solver.BruteForceSolver. You can get rid of many lines of imports at the top of your module and help yourself out when you are reading many lines deep in your own module, far from those imports, if you instead do this:\n# just import one thing, don't pollute namespace\nfrom . import solvers\n\n...\n# ~150 lines in\n    if solve_strategy == \"entropy\"\n        # ah, this is one of many solvers in this\n        solver = solvers.EntropySolver()\n    elif solve_strategy == \"shannon\"\n        solver = solvers.ShannonSolver()\nOne slight drawback of this terse approach is you can end up shadowing the most intuitive variable name for a class instance with a module that has a similar name. I.e., if I rename my module pkg_solver -&gt; solver then I won‚Äôt be able to do from . import solver at the top and then later also say solver = solver.EntropySolver(), because the variable name solver representing my class instance will clobber the name in the namespace that represents my solver module. This will cause Python‚Äôs head to explode (and yours). In this case I prefer to either use an absolute import internally, import pkg.solver, or to alias internally, e.g., from . import solver as solver_classes, so that an external user still can write something simple like pkg.solver.\n{:footnotes} *"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#you-should-know-sub-packages-exist",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#you-should-know-sub-packages-exist",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "You should know sub-packages exist",
    "text": "You should know sub-packages exist\nAgain, this is less about naming, and more about structuring internals. But it falls under the same category of ‚Äúthing I see that tells me you might not yet have a mental model of how to organize your code to make it easier for you to maintain in the long run‚Äù.\nYou should know (if you don‚Äôt already) that you can make a sub-package inside your package. You do this the same way you make the package itself, by adding the magical __init__.py file that tells Python ‚Äúthis directory is a package‚Äù.\nHere we add a solvers sub-package to the emgtoolkit package from our example.\nemgtoolkit\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îî‚îÄ‚îÄ __init__.py\nHere is an example in the Python docs on modules: https://docs.python.org/3/tutorial/modules.html#packages\nGoing back to our example from above, we can refactor our (presumably gigantic) solver module into a handful of modules inside the solver sub-package:\nemgtoolkit\n‚îú‚îÄ‚îÄ load.py\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ simulate.py\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ brute_force.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entropy.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gibson.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ random_walk.py\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shannon.py\n‚îú‚îÄ‚îÄ timestamp.py\n‚îî‚îÄ‚îÄ __init__.py\nThen you can use imports so that, from the perspective of the user, they have access to the same modules with classes, functions, etc., that they had before. You do this by importing all the classes from each module in the sub-package inside the __init__.py of that sub-package.\n\"\"\"solver sub-package\"\"\"\n# this is __init__.py\nfrom .entropy_solver import EntropySolver\nfrom .shannon_solver ShannonSolver\nfrom .gibson_solver GibsonSolver\n...\nThis kind of looks like the thing I told you to not do above. But the difference here is that you are importing inside the __init__.py file, where (ideally) you are not hiding any functions; instead you are just doing some boring boilerplate imports here to make your life easier somewhere else. This lets you be more intentional about your API too. You can have some helper functions inside the sub-package modules that users don‚Äôt really need. To broadcast to the world the stuff you think people need, you import just that stuff inside your sub-package __init__.py\n\nPython doesn‚Äôt have a concept of ‚Äúpublic and private members of objects‚Äù, as languages like Java do, so there‚Äôs no (good) way for you to absolutely prevent someone from importing and accessing things. Instead Python follows the principle of ‚Äúwe‚Äôre all adults here‚Äù, and uses some conventions to indicate things like private and internal functions. See the section of PEP8 on naming, in particular, where it talks about _single_leading_underscore as a weak ‚Äúinternal use‚Äù indicator.\n\nThe other advantage of breaking code up into many modules within a subpackage, from your perspective as a maintainer, is that you can easily focus on one little chunk of code at a time. I promise that in the long run, this will help you, especially when you need to context switch and work on multiple things at once. Especially if there‚Äôs some helper functions and you‚Äôre not having to scroll or jump around through 3000 lines of code to find them."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#finally-dont-name-a-module-package.utils-or-package.utilities",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#finally-dont-name-a-module-package.utils-or-package.utilities",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Finally, don‚Äôt name a module package.utils or package.utilities",
    "text": "Finally, don‚Äôt name a module package.utils or package.utilities\nSomeone even more jaded than me has already said this: https://breadcrumbscollector.tech/stop-naming-your-python-modules-utils/\nThe basic idea is that the concept of utilities is so nebulous that more and more things will end up crammed into this module, that are less and less related to each other. This is especially likely if multiple people are developing a package, and they are tempted by the name utilities to add just one more helper or validation function inside that (now gigantic) module when trying to add a new feature.\nHold on, friend. Take a step back, take a deep breath. It‚Äôs okay to add a module with just a single function. You can just have a module named timestamp with only one function get_timestamp, and have it be only 10 lines. Please believe me, it will make the codebase easier to read, it will make internal usage of the function easier to read, it will make it easier to write quick unit tests. You do not want to hold 500 lines of utils in your head when you‚Äôre trying to track down a bug. If you don‚Äôt like that your top-level namespace gets cluttered by these little modules, than pull out our sub-package trick from above to push those modules down a level.\nSo that‚Äôs me saying what that other blog post said, after I said they already said it. All I want to add here is that the same logic from above applies: you want people to use your package. So give the modules very specific names so people know exactly what everything is doing. It will help your potential users and it will help future you."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#take-homes",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#take-homes",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Take-homes",
    "text": "Take-homes\nAt the risk of repeating myself, let me tell you again why you‚Äôd want to take these tips to heart. You want people to use your library that you‚Äôre sharing with the world. It‚Äôs amazing; people can go onto the internet and just use the tools you put all that effort into! As a researcher, this is the kind of instant gratification you can‚Äôt get when you are taking on the Herculean task of putting reality into a headlock with an experiment.\nSo make the most of it! Give your Python packages and modules names with just a few letters, and make use of imports and sub-packages to further structure the namespace of your package so that it‚Äôs convenient to work with. This will also benefit you in the long run when you‚Äôre working with your own code.\nSince I‚Äôm writing for research scientists, I will of course end the discussion by claiming that this blog sets the stage for future research. A good question would be, has anybody done any research supporting my claims that these tips will help you and others read and use your code? If I ever finish reading The Programmer‚Äôs Brain, I‚Äôll probably be able to tell you. Stay tuned for another post. üôÇ"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#footnotes",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#footnotes",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee similar comments from core Python dev Brett Cannon in this post, https://snarky.ca/if-i-were-designing-imort-from-scratch/ in the section ‚ÄúYou can only import modules‚Äù.‚Ü©Ô∏é"
  }
]