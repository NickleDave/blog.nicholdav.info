[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hoping machine",
    "section": "",
    "text": "Domain-driven software design is a good idea, still\n\n\n\n\n\n\ndomain-driven design\n\n\ncomputer science\n\n\nresearch software engineering\n\n\n\nDomain-driven design might be just data abstraction with doodles, but you should care about it anyways\n\n\n\n\n\nJan 2, 2025\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nFour tips for structuring your research groupâ€™s Python packages\n\n\n\n\n\n\nresearch software engineering\n\n\nPython\n\n\n\nHow to structure your Python package so other researchers want to use it\n\n\n\n\n\nDec 26, 2022\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nMake your own academicpages site from scratch with jekyll\n\n\n\n\n\n\nacademia\n\n\n\nInstead of forking academicpages, make it yourself to better understand jekyll\n\n\n\n\n\nMar 16, 2022\n\n\nDavid Nicholson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html",
    "href": "posts/2025-01-02-domain-driven-design/index.html",
    "title": "Domain-driven software design is a good idea, still",
    "section": "",
    "text": "This post falls in the category of â€œme writing about how my thinking has evolved about research and softwareâ€. If you are a researcher that writes software, then you might get something out of it. Especially if youâ€™re not familiar with the idea of domain-driven design. What I hope to convince you of is that, sure, domain-driven design is just as obvious an idea as it sounds, but you should still be thinking about it. Iâ€™ll get there by saying a little about one book Iâ€™ve been reading recently, Structure and Interpretation of Computer Programs."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#what-is-domain-driven-design",
    "href": "posts/2025-01-02-domain-driven-design/index.html#what-is-domain-driven-design",
    "title": "Domain-driven software design is a good idea, still",
    "section": "What is domain-driven design?",
    "text": "What is domain-driven design?\nBut first, let me introduce domain-driven design, and tell you why you might care about it. Sometime in 2022-2023, I read Domain-Driven Design by Eric Evans, and I got really excited about it. (You can get it from bookshop.org here, and if youâ€™re feeling dangerous you can probably find a PDF of it on a random GitHub repository.) I ended up reading it because I had been reading Architecture Patterns with Python, and they mentioned it in the introduction. Full disclosure: I have not finished either of these books. In fact, I havenâ€™t finished a lot of books, but thatâ€™s maybe the undiagnosed ADHD talking. I did spend a lot of time with the first few chapters of both, though. If you do nothing else, read the first chapter of Evansâ€™ book, where he relates the story of how he worked with some electrical engineers to design software they would use to design printed circuit boards (AKA PCBs). If you have ever gone through the process of designing software for some real-world domain, I bet it will really resonate with you. Or, you know what? Iâ€™ll dare to say that, even if you have only ever written nerdy software tools for the domain of other software nerds, you still might find that the story resonates with you. Itâ€™s an interesting story for a couple of reasons. First of all, you have a feeling that he is almost an anthropologist, going into this unfamiliar tribe of electrical engineers so he can learn their culture. I think this is a familiar feeling for anyone who has tried to translate some real-world domain into software, even if itâ€™s part of a culture they feel like they belong to. Second, you really get a feel for his process. At the beginning, he makes mistakes. He tries to understand their jargon word-for-word. Then he asks them to specify in detail what they think the software should do. Neither of those approaches were ever going to work well. Finally he hits upon the idea of asking them to draw out diagrams of their process and how the software should interact with it. These are simple, rough box and arrow sketches as he shows.\n\n\n\nevans figure 1.2\n\n\nI happened to read this at the same time that I had been sketching out some initial ideas for the VocalPy library that I develop. You can see some of these sketches here: https://github.com/vocalpy/vocalpy/issues/19\n\n\n\nschematic of library named vocles from linked github issue\n\n\nIf you were to click through to the libraryâ€™s docs, you might notice that these bear little resemblance to VocalPy now. I think this is actually a good thing â€“ more on that below. (You might also notice at the time I was thinking of calling it vocles ğŸ¤¦ â€“ this is a very tortured pun, everyone please clap for me showing enough restraint for once in my life to not deploy a tortured pun.)\nI donâ€™t actually remember which came first: these sketches, or me reading the book. I think that I actually drew the sketches first, and had them sitting around on a desk forever, until finally it hit me that I should add them to the repo to document my design process. And then reading this part of Evansâ€™ book really made me think that drawings like this should be integral to the design process. Part of what I want to say here is that, you should be doing this, if youâ€™re not already, and whatâ€™s more, you should be including it in your docs for your software. And this goes for all software, unless you are literally writing such a boring cookiecutter CRUD app that a so-called Large Language Model can regurgitate it perfectly for you after being â€œtrainedâ€ on the actual work of human beings.\nAt this point, you might be thinking, â€œwrite code in terms of your domain, yeah, sure, everybody does thatâ€. Like I said, I got really excited reading this stuff and told people about it at the job I had at the time. I made a big deal of presenting parts of the book, and talking about how we could use this approach for what we were working on. And I got this very underwhelmed response of â€œYeah, we sort of already do that. Arenâ€™t you just describing object-oriented programming?â€ Yes, but no! Iâ€™ll come back to the â€œno, we arenâ€™t doing that belowâ€, but first, the yes. We should realize this is what weâ€™re already doing and be very explicit about it! The domain should be at the front of our mind at all times, and we only should be iterating on the design of our software insofar as it relates to the domain!\nHere Iâ€™ll say what I said in that work meeting when I got that underwhelmed response: domain-driven development isnâ€™t just thinking about the domain. Even though we all sort of subconsciously think of the domain when we design our code, Evans advocates for a specific development process, that he says is required for his approach to design to work. The important part here is that he sees his process as a form of extreme or Agile programming. If you donâ€™t know what those are, what you need to know is that they are more iterative then previous approaches based on â€œelaborate development methodologies that burden projects with useless, static documents and obsessive upfront planning and designâ€, as he puts it. Instead, Evans focuses on writing code that has a bare bones implementation he can test right away. â€œDevelopment is iterative.â€ Of course, this is one place where Python, my main programming language, shines. Itâ€™s really easy to iterate interactively in a Jupyter notebook with a bare-bones implementation of your sketch of an API. Of course, later you should do some proper engineering instead of living in Jupyter notebooks, so you donâ€™t have to worry about someone giving a preachy lecture in the form of a conference talk that condemns you for your naughty programming practices. His other requirement for the development process is that â€œ[d]evelopers and domain experts have a close relationship.â€ If you are a researcher who programs, well, hopefully you already have a close relationship with yourself. And with your collaborators and colleagues. This second requirement naturally gives rise to one of the key ideas from the book, that of ubiquitous language. This is a sort of pidgin language that the domain experts and software developers arrive at together through the iterative process of development. The words in this ubiquitous language correspond to key concepts in the domain that the software needs to capture, the things that developers and domain-experts realize they should focus on, as they iterate. Ubiquitous language â€œembeds domain terminology in the software systems we buildâ€, as Martin Fowler puts it in this post. Itâ€™s this continous process of developer and domain expert iterating together that really appeals to me."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#how-ive-used-domain-driven-design",
    "href": "posts/2025-01-02-domain-driven-design/index.html#how-ive-used-domain-driven-design",
    "title": "Domain-driven software design is a good idea, still",
    "section": "How Iâ€™ve used domain-driven design",
    "text": "How Iâ€™ve used domain-driven design\nOk, now you have an idea of what domain-driven design is. You might ask yourself, have I done anything with this or do I just like pontificating into the void about ideas from computer science and tech books? Even if I havenâ€™t gone back to finish the book and immerse myself in every detail, the core idea has really stuck with me. So much so that you can see that I cited the book in the Proceedings paper where I first introduced VocalPy, and where I included similar schematics.\n\n\n\nfigure 1 from VocalPy proceedings paper\n\n\nAs I mentioned above, even by the time I got to this first Proceeding paper, the design of the library had evolved. But this is a good thing â€” I did exactly what Evans prescribed, and continued to iterate on the design of the package. Doing so made me realized which parts were actually useful, that I wanted to retain in the core. I think sketching things out has also helped me understand why the things I ended up taking out are still useful, just not in the way I had thought at first. The library at first was very focused on the idea of capturing a dataset of specific file types, and then being able to save this dataset in the form of a SQLite file. You can see where I was really focused on treating the dataset as if it were part of an app, like in the architecture book. I do think this is still important, but it is not the core of what the library does â€“ I realized later that the core data types needed to be things like sounds, spectrograms, annotations, the things that a researcher studying animal communication and using bioacoustics would be talking about. So, basically, I did the anthropological exercise, as in Chapter 1 of Evansâ€™ book, but instead of doing it with other people, I started by doing it with the part of my brain that claims to know things about acoustic communication. (I have since engaged with other people who actually know these things and can give me good feedback.)\nI also came back to the idea of domain-driven development in a talk I gave about VocalPy where I talked a little bit about how it maybe clashes with some recommendations for programming in scientific Python."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#domain-driven-design-is-just-data-abstraction-with-doodles-and-you-should-do-it-anyway",
    "href": "posts/2025-01-02-domain-driven-design/index.html#domain-driven-design-is-just-data-abstraction-with-doodles-and-you-should-do-it-anyway",
    "title": "Domain-driven software design is a good idea, still",
    "section": "Domain-driven design is just data abstraction with doodles, and you should do it anyway",
    "text": "Domain-driven design is just data abstraction with doodles, and you should do it anyway\nOk, so now let me circle back around, talk about why, sure, domain-driven design is not a new idea (as Evans himself acknowledges right at the start of his book), and why you should be doing it, or doing even more of it. This is where I come back to the â€œnoâ€ part of â€œDo we already do this? Yes and no.â€ In the discussion at the end of that talk, I said just what Iâ€™ve said here, that a lot of people react as if, â€œso, yeah, we already do thatâ€. If thatâ€™s so, then show me the doodles! Show me your mental model of your domain â€” put it in your docs! Let me read it, let me actually see these schematics, even if they are just doodles, it helps me to know how your thought process evolved. All I can see right now is this insurmountable mountain of code, and I donâ€™t even know where the path starts so I can scale it! I know that there are examples of people doing this, e.g., in the scientific Python community where I spend most of my time, but I think itâ€™s fair to say that this is not the norm. I donâ€™t know that I have ever seen diagrams showing how the design evolved, as part of an iterative development process. I canâ€™t help but feel like thatâ€™s exactly the sort of thing that could help people get up to speed on how the code works.\nAnd now the moral of the story at the end. I now know for sure that these ideas have been around longer than Eric Evansâ€™ book, because I have been attempting to read yet another book, the aforementioned Structure and Interpretation of Computer Programs (AKA â€œSICPâ€, and I am reading the Javascript edition, if you even care). I ended up reading this book because I have begun working my way through the reading list on teachyourselfcs.com. That is another topic that could be a blog post unto itself, but suffice to say that it is a source of some shame that I ostensibly make my living by programming computers, but I only have the vaguest idea of how computers work, or how programming works, and so I have this need to fix that. I have also realized that, of course, computer scientists also think in terms of models of computers, that is, their domain, and this is why itâ€™s easier to learn about computers by learning their models. This is why itâ€™s helpful to learn git by actually learning how git works as others have noted, and this is why I think it has actually been worth reading SICP, because it gives me two or three different mental models of how computer programs work. Again, maybe its old news to you, but I feel like I really need a reminder that we constantly build and then throw away scratch models of whatever weâ€™re working on, and this includes stuff we do with computers. Given that SICP has the nickname â€œThe Wizard Bookâ€, I canâ€™t be the only one who falls into this way of thinkingâ€” that programming is modern sorcery, and I should sit before the blank screen like a cyberpunk Zeus and have the program emerge fully-formed from my forehead. (I am mixing Greek mythology and wizardy in my metaphors. Whatever, you get the point.)\nThis is how I ended up finding domain-driven design in SICP, and having to admit to myself that, yeah, this idea has been around forever. Lo and behold, when I got to chapters 2 and 3, there I saw that we were talking about data abstraction and designing programs for modeling. Sound familiar? Let me quote you this bit from chapter 3:\n\nOne powerful design strategy, which is particularly appropriate to the construction of programs for modeling physical systems, is to base the structure of our programs on the structure of the system being modeled. For each object in the system, we construct a corresponding computational object. For each system action, we define a symbolic operation in our computational model. Our hope in using this strategy is that extending the model to accommodate new objects or new actions will require no strategic changes to the program, only the addition of the new symbolic analogs of those objects or actions. If we have been successful in our system organization, then to add a new feature or debug an old one we will have to work on only a localized part of the system.\n\nWell there it is, domain-driven design in a nutshell. And if so great and venerable a source as SICP deigns to talk about it, if these supposedly very smart people think itâ€™s worth discussing in the introductory sections of their book chapters, then it must be an idea worth thinking about. QED."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "",
    "text": "Update 2025-01-08: I switched to quarto, but I refuse to write a blog post about it.\nUpdate 2022-12-17: I added a home page and a blog to my site, so I no longer use a set up exactly like the academicpages theme, but Iâ€™m leaving this post up to document the process (and because itâ€™s currently my only post ğŸ˜­)\nIn this post I document the process I went through to set up a peronsal web site with a structure similar to the academicpages theme used by many academics (https://academicpages.github.io/). Iâ€™m writing the post for my future self, and for you if you want to do the same."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Step-by-step guide to developing your own â€˜academicpagesâ€™",
    "text": "Step-by-step guide to developing your own â€˜academicpagesâ€™\nHereâ€™s the summary version first, so you know what youâ€™re getting into: 1. set up a jekyll development environment 2. make the landing page be your about page 3. make the sidebar show your profile with links 4. add links to publications, talks, etc., in the nav bar at the top of the page"
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#why-would-you-bother",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#why-would-you-bother",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Why would you bother?",
    "text": "Why would you bother?\nI wanted a site similar in style to academicpages (https://academicpages.github.io/), with links in the sidebar to Google Scholar, OrcID, etc., and the ability to use jekyllâ€™s â€œcollectionsâ€ feature to easily organize publications, talks and teaching. But I also wanted the flexibility to change themes, which is not easy to do with academicpages.\nIf youâ€™re like me, and you mainly write code in Python, you might naturally use a static site generator written in Python (as I did for a while, see next section). Using jekyll, thatâ€™s written in Ruby, might feel like a big jumpâ€“ the big pain point in switching languages is often getting familiar with their tooling. As a Pythonista, of course I want to support Python libraries, and some of the static site generators like pelican are battle tested with themes that are very versatile, like their version of bootstrap. But somehow minimal-mistakes and other jekyll themes just look better to my (untrained) eye.\nAnd as a programmar and developer, it might be a fun exercise in using libraries in a language besides Python. Itâ€™s interesting to experience the tooling in the ecosystems of other programming languages."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#how-did-we-get-here",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#how-did-we-get-here",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "How did we get here?",
    "text": "How did we get here?\nIâ€™ve had a personal web page for sometime that I set up with pelican, a static web page generator in Python. Basically I adopted my approach from the one Jake Vanderplas took for his â€œpythonic perambulationsâ€ blog. However I wasnâ€™t happy with how my page looked (which has nothing to do with Jake Vanderplas, and everything to do with my moribund graphic design and css/html skillz). And it was time to update my site anyway. Recently I noticed a collaborator had set up their own personal site using the excellent academicpages repository, developed by Stuart Geiger. academicpages is great if you are trying to survive in academia and you donâ€™t have time to bother learning how to use a static site generator. With academicpages you just want to follow a couple steps to add your own content to some existing template, to easily get a site.\nSome background: academicpages is a fork of minimal-mistakes, a very popular theme for the jekyll library. jekyyl is a static site generator written in the ruby programming language. You can think of it as analogous to pelican in Python (or Ruby developers might tell me that pelican is analgous to jekyll). One advantage of using jekyll is that GitHub really likes jekyll, letting developers easily create web pages for themselves or documentation for their projects through the GitHub Pages service. And itâ€™s free, another plus for academics. Stuart modified the minimal-mistakes theme in such a way that other academics could simply fork its repo on GitHub and use the web interface to add their own content, without needing to know how to use jekyll or how to use any developer tools like git.\nSo I knew I wanted a site like academicpages, but I also knew there were things I wanted to modify, such as the theme / template. Thereâ€™s little documentation in the academicpages guide about what changes were made to the minimal-mistakes theme, and why. How did Stuart evolve the template from your standard jekyll minimal blog page to a very specific set-up for academics? Unique features of academicpages include that it lands on the about page and shows a profile in the sidebar with links to academia specific sites, and includes tabs like â€œpublicationsâ€, â€œtalksâ€, etc.? I tried looking at the git commit history but couldnâ€™t piece it together. I figured there couldnâ€™t be too too many steps to setting up a similar site on my own."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages-1",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages-1",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Step-by-step guide to developing your own â€˜academicpagesâ€™",
    "text": "Step-by-step guide to developing your own â€˜academicpagesâ€™\nAgain, hereâ€™s the outline of what weâ€™re going to do: 1. set up a jekyll development environment 2. make the landing page be your about page 3. make the sidebar show your profile with links 4. add links to publications, talks, etc., in the nav bar at the top of the page\n\nSetting up a development environment\nThis is a thing that might be new to academics not familiar with software engineering, but the jekyll and ruby devs have worked really hard to make it easy.\n\nset up a basic environment for working with jekyll\n\ntheir quickstart is here: https://jekyllrb.com/docs/\nIâ€™m on PopOS, a Linux distribution similar to Ubuntu, and I use oh-my-zsh, so I followed these instructions: https://jekyllrb.com/docs/installation/ubuntu/ except I changed .bashrc to .zshrc\n\nthen I followed the directions for managing dependencies with bundler so that I could install the minimal-mistakes template as a gem instead of forking their repo and modifying it\n\nhttps://jekyllrb.com/tutorials/using-jekyll-with-bundler\n\n\n\n\nMaking the â€œlanding pageâ€ be your â€œaboutâ€ page\nThis is the first thing thatâ€™s specific to our site design.\n\nuse the redirect plugin so that the site lands on â€œaboutâ€\nadd an about.md â€“ make sure you copy the YAML front matter from academicpages\nmake sure _config.yml specifies defaults for pages so that your theme gets applied to this about.md file\n\nI copied the #defaults section from the academicpages _config.yml\n\n\n\n\nMaking the sidebar show your profile, with links\nNow weâ€™re cooking with academicpages gas! Or something\n\nto make the author profile in the sidebar render all the links that are in academicpages but not in minimal-mistakes, i.e.Â academia specific things like a Google Scholar page, ORCID profile, etc., youâ€™ll need to add an author-profile.html in an _includes directory. Basically I copied the author-profile.html from minimal-mistakes and then added the relevant if-then statements in the author-links section.\nfor things like an author pic, I added them in assets/images/ â€“ I think this is consider â€œidiomatic Jekyllâ€ even though the academicpages repo just has an images folder in its root. Doesnâ€™t matter too much as long as you specify the correct relative path in your _config.yml\n\n\n\nAdding links to publications, talks, etc., in the masthead nav bar\nUnique to academicpages are the links in the navigation bar at the top of the page to pages with lists of publications, talks, and so on.\nIf you want the same thing, thereâ€™s two things youâ€™ll need to do: 1. youâ€™ll need to copy the â€˜navigation.ymlâ€™ file from academicpages, placing it in a data/ subfolder in your project root, and modify it as you see fit. 2. add two related sections in your _config.yml: + a â€˜collectionsâ€™ section, like this one in the academicpages _config.yml. + and corresponding keys in your defaults section as shown here in the academicpages _config.yml.\nThis is explained very briefly in the about.md of academicpages but hereâ€™s a quick explainer of how it all works. minimal-mistakes lets you add links to the masthead by supplying a file called navigation.yml. This is a standard approach in jekyll. There are other uses for data files. Whatâ€™s specific to minimal-mistakes is that you add these links to the nav bar by specifying a main key in navigation.yml, as described here: https://mmistakes.github.io/minimal-mistakes/docs/navigation/. In the case of academicpages, the links have the names of the specific sections in the navigation.yml with the keys â€œpublicationsâ€, â€œtalksâ€, etc."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#coda-publishing-etc.",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#coda-publishing-etc.",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Coda: publishing, etc.",
    "text": "Coda: publishing, etc.\nAfter making the changes just described, I had a site with a structure similar to academicpages.\nTo actually publish the site, I still use a workflow similar to what Jake Vanderplas uses for his blog: https://github.com/jakevdp/jakevdp.github.io-source This centers around a Makefile with commands for build and serve.\nThe key thing that makes it easy to publish to Github Pages is to use the ghp-import package, as suggested by the pelican docs: https://docs.getpelican.com/en/latest/tips.html#project-pages. Of course, jekyll gets special treatment on GitHub so itâ€™s kind of overkill, but I still like having a separate repo that I just push the .html and .css files to without thinking about it.\nSo this is how I have my site set up now! Stay tuned for it to change suddenly, because as a developer I love to spend hours farting around with tools that let me avoid real work. Iâ€™ll keep this post up for posterity anyway."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "",
    "text": "Update 2025-01-08:\nI think this post gives better advice overall on designing a Python library API:\nhttps://benhoyt.com/writings/python-api-design/\nYou should read that one first, then come back and read this one for some examples of what not to do.\nThis is one of those petulant posts from someone who writes software. A post from one of those people that describes some library they wrote as â€œopinionatedâ€, as if the rest of us have been living in fear of expressing our opinions through software.\nSo, sorry in advance. But I want to talk about some things I see a lot in Python packages shared by research groups.\nAt the highest level, thereâ€™s two things I see: one, researchers name their modules in a way that might make sense when youâ€™re writing your own code, but can seem very verbose or non-intuitive when you are someone else on the outside reading or using that code. Two, I see a lot of code that doesnâ€™t structure itself in a way that makes it easier for people to read it and to use it. And youâ€™re sharing your code because you want people to use it, right?\nI think a lot of packages from research labs end up this way in part because researchers donâ€™t have a good mental model of the mapping from their written code to the package they import. In other words, they donâ€™t have a clear picture of how Python translates the directory structure of their code and its internal import statements into a package name with modules that can be accessed with the dot operator, like so: package.subpackage.module.function.\nTo use a technical term, the code does not fully leverage its own namespace, the literal mapping from names of things in the package to the functions and classes that they refer to. If I may invoke the holy sayings of the revered masters, â€œnamespaces are a honking great ideaâ€. To a wizened software engineer, that phrase from the Zen of Python might sound like Python is patting itself on the back for something that basically every modern language does. But for many researchers that are getting their first experience designing a software library, it might seem surprising that Iâ€™m drawing a connection between the pile of files that constitues their code and an abstraction from computer science. If it sounds surprising to you, maybe itâ€™s because you donâ€™t (yet) have a good concept map of how namespaces relate to naming your modules and structuring your package.\nSo let me tell you a little bit about that, and how you can build on it to make your code much more accessible. I donâ€™t claim to have a perfect mental model of Python packages, but at least I have fought enough with my own code, and read enough of others peoplesâ€™ code, that I think I can say something useful here. This post contains some things Iâ€™ve learned the hard way, to hopefully save you from repeating the mistakes of past me.\nIâ€™ve boiled it down to four tips, that Iâ€™ll explain in more detail below.\nHereâ€™s the high-level version:\nOf course, it goes without saying that these are absolute rules that came to me in a dream where Guido Van Rossum emerged from a burning bush and handed them to me on a freshly-minted PEP. As such, you should never violate them for any reason, unless you feel like it. (Those last two sentences should be written in the sarcasm font.) More seriously, you could call these rules, but there are sometimes good reasons to not follow them to the letter, like weâ€™ll see below.\nOne other thing to say before we get started: I will use some examples here inspired by real life, but namespaces have been changed to protect the innocent. I promise my goal here is not to name shame, but instead to help you make your code as accessible as possible. I also want to note this is not meant to be a whole tutorial, just some pointers on how to pick module names and how to structure your package in a way that makes your code more immediately accessible and more readable. For an introductory tutorial to packages and modules, please see https://realpython.com/python-modules-packages/."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#an-example-of-what-not-to-do",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#an-example-of-what-not-to-do",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "An example of what not to do",
    "text": "An example of what not to do\nHereâ€™s the scenario: You are really into sharing your research code written in Python. Great! Sharing code just makes sense to you. Your lab is getting on board with this too. You made a GitHub organization for the research group (instead of making an individual profile with the lab name! Please donâ€™t do that, and make an org page instead, so we can see whoâ€™s in your group and understand who contributes what! For when I want to write you an email thanking you for your work, or ask you to collaborate, or figure out who I want to hire away from academia into the private sector ğŸ˜ˆ).\nNow everybody in the lab is forking their repos to that org, so you can collaborate and all rely on the same version of the same code. I go to your labâ€™s org page and check out one of the repos, and I see something like this.\nelectroymyographytoolkit\nâ”œâ”€â”€ emg_load_inchan_data_four_channelinkls.py\nâ”œâ”€â”€ emg_main.py\nâ”œâ”€â”€ emg_simulate.py\nâ”œâ”€â”€ emg_solver.py\nâ”œâ”€â”€ emg_utils.py\nâ””â”€â”€ __init__.py\n\nIn the words of a wise man:\n\nOh No Baby! What Is You Doin???\n\n â€” nicknpattiwhack_"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#what-you-should-do-instead",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#what-you-should-do-instead",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "What you should do instead",
    "text": "What you should do instead\nPlease! Help as many people as possible actually use your code by avoiding naming and package structures like that! Instead you want something like this:\nemgtoolkit\nâ”œâ”€â”€ load.py\nâ”œâ”€â”€ main.py\nâ”œâ”€â”€ simulate.py\nâ”œâ”€â”€ solvers\nâ”‚Â Â  â”œâ”€â”€ brute_force.py\nâ”‚Â Â  â”œâ”€â”€ entropy.py\nâ”‚Â Â  â”œâ”€â”€ gibson.py\nâ”‚Â Â  â”œâ”€â”€ __init__.py\nâ”‚Â Â  â”œâ”€â”€ random_walk.py\nâ”‚Â Â  â””â”€â”€ shannon.py\nâ”œâ”€â”€ timestamp.py\nâ””â”€â”€ __init__.py\nThe changes I made above follow the aforementioned four tips. Hereâ€™s they are again, the short version of what you want to do:\n\nGive your packages and modules terse, single-word names whenever possible.\nImport modules internally, instead of importing everything from modules. (You canâ€™t see this directly in the example above, but Iâ€™ll show it below.)\nMake use of sub-packages.\nPrefer modules with very specific names containing single functions over modules with very general names like utils, helpers, or support that contain many functions.\n\nAll of these rules help you make code written with your package more readable from the outside, when someone else uses it from a script. Rules 2,3, and 4 in particular can also help make your code more readable from the inside, when you revisit it after you spent six months in the lab fighting with weird noise from your electrophysiology rig or an IHC protocol or whatever it is that scientists do, I donâ€™t remember anymore ([laughs in post-academic])."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.pkg_module",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.pkg_module",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "Please donâ€™t name your modules package.pkg_module",
    "text": "Please donâ€™t name your modules package.pkg_module\nOkay, I will briefly, just for one paragraph, get really â€œopinionatedâ€. I am not yelling at you. Iâ€™m yelling with you, from the perspective of you as a future user and reader of your own code. (Borrowing a concept from physics while simultaneously breaking its laws, we change our frame of reference and do some time travel so that what you named your modules is no longer a problem for â€œfuture youâ€ to solve.)\nHereâ€™s our example package layout again:\nelectroymyographytoolkit\nâ”œâ”€â”€ emg_load_inchan_data_four_channelinkls.py\nâ”œâ”€â”€ emg_main.py\nâ”œâ”€â”€ emg_simulate.py\nâ”œâ”€â”€ emg_solver.py\nâ”œâ”€â”€ emg_utils.py\nâ””â”€â”€ __init__.py\n\nyelling:\nLook at this. What is this?! No one wants to type out package.pkg_solver! Why are you making me redundantly type the package name again after I just typed it? Only instead youâ€™re making me remember and type some abbreviated version of the package name that you dropped some vowels from arbitrarily? And, and youâ€™re making me type an underscore, that my hand has to go find the shift key for! Every time!!! Yes I know that tab complete exists! This is still too much typing!!! Why do you hate me?\nMore calmly:\nThat might seem like a weirdly specific example to you, but I have seen naming schemes like this more than once (hence, this post). I really do think it has something to do with the way other researchers are thinking about code while writing it and when importing it. They want to import a module from their package and know where it came from, so they put the package name in the module name. I guess? ğŸ¤· Instead of doing anything like that, just name your package and modules something terse from the get-go, like\nemgtoolkit\nâ”œâ”€â”€ load.py\nâ”œâ”€â”€ main.py\nâ”œâ”€â”€ simulate.py\nâ”œâ”€â”€ solvers\nâ”‚Â Â  â”œâ”€â”€ brute_force.py\nâ”‚Â Â  â”œâ”€â”€ entropy.py\nâ”‚Â Â  â”œâ”€â”€ gibson.py\nâ”‚Â Â  â”œâ”€â”€ __init__.py\nâ”‚Â Â  â”œâ”€â”€ random_walk.py\nâ”‚Â Â  â””â”€â”€ shannon.py\nâ”œâ”€â”€ timestamp.py\nâ””â”€â”€ __init__.py\nNow in your scripts you can write out the whole package name, while at the same time having it be more succinct and clear what part of the packageâ€™s namespace youâ€™re referring to. E.g., emgtoolkit.simulate instead of electromyographytoolkit.emg_simulate. You might have noticed some other things changed in the names, too. Those changes relate to the other tips, that Iâ€™ll say more about below."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.incredibly_long_technical_name",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.incredibly_long_technical_name",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "Please donâ€™t name your modules package.incredibly_long_technical_name",
    "text": "Please donâ€™t name your modules package.incredibly_long_technical_name\nThere is also an even more extreme form of verbose module names, that takes the form of:\npkg/\n  incredibly_long_technical_name_or_specific_task\nSometimes this is justified, if itâ€™s the core functionality of your package and you really need to clearly communicate to everyone in the universe what the package does. E.g., sklearn.model_selection has a very specific meaning, and itâ€™s hard to capture with an abbreviation, and the library is trying to capture basically several sub-fields of machine learning within this sub-package. I am okay with tab-completing this name just so itâ€™s clear to all of us what the heck weâ€™re doing. But pkg.preprocessing_electrophysiological_data is not a great name. Especially if your package only deals with electrophysiological data. You can just say pkg.preprocess, itâ€™s fine.\n\nInstead, make module names general, and move specifics to function names\nOften these really long module names can be a very specific thing you need to do. Here again you can make things more terse by moving the more specific part to a function name, while keeping the more general part as a module name. For example, instead of\nelectroymyographytoolkit\nâ”œâ”€â”€ emg_load_inchan_data_four_channels.py\nname the module load, and name a function in that module inchan_data_four_channels, so that you can type out:\n&gt;&gt;&gt; emgtoolkit.load.inchan_data_four_channels()\nYour intention is still obvious. But you rely on attribute access to make that intention clear, while simultaneously more succinct. This also means you have left yourself room later to add other load functions in your module, like\n&gt;&gt;&gt; emgtoolkit.load.inchan_data_accelerometer_channel()\nor whatever. Trust me, there will be a later. Leave space in your namespace."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#import-modules-not-functions-and-classes-for-readability",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#import-modules-not-functions-and-classes-for-readability",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "Import modules, not functions and classes, for readability",
    "text": "Import modules, not functions and classes, for readability\nThis is less about naming and more about importing, but itâ€™s related because I feel like this same anti-pattern arises from someone not understanding what it is that package structure gives you. It gives you a logical grouping thatâ€™s readable not just from the outside but also from the inside. Let me explain.\nI often see something like this in an internal module:\n# inside main.py\nfrom pkg_solver import (\n    EntropySolver,\n    ShannonSolver,\n    GibsonSolver,\n    ...\n    # 10 more lines of class imports from a single module (!)\n    BruteForceSolver,\n    RandomWalkSolver\n)\nLetâ€™s say this is in emgtoolkit/main.py. Going back to the overall goal of this post, letâ€™s think about how the import above will affect the namespace of your package, as seen from the outside. if I am using your package, one of the first things Iâ€™m going to do is inspect the content of emgtoolkit.main, e.g.Â by running dir(emgtoolkit.main) in a Python REPL, since that name signals to me very loudly that you think of this as its main interface or API. With an import statement like the one above, when I tab complete while working with this module, I am going to be faced with a wall of Solver classes that obscures the true function of the module. This is not the solver module! Thatâ€™s some other module! If this is a high-level module that you expect me to access as a user, then please avoid polluting it with all these names. One of the ways you can do this is by making use of sub-packages, as Iâ€™ll talk about below.\nI want to make a second point here, that is less about making external use of your code readable, and more about making it readable internally, within the code base. I know that right now while you are hacking on the code, you feel like you have all the low-level context about what all the moving parts are doing. But if you want to make life easier for yourself six months from now, and easier for everyone else that has to use your code, write in a way that surfaces that context. Write in a way that makes it much more obvious where all the functions and classes come from, leveraging the logical grouping that you spent so much time boiling down into concise module names.\nPlease, for your future self and everyone else, make the code readable by importing just the module 1, and then referring to those classes (or function or whatever youâ€™re referring to) via attribute access, i.e.Â with a dot, like solver.BruteForceSolver. You can get rid of many lines of imports at the top of your module and help yourself out when you are reading many lines deep in your own module, far from those imports, if you instead do this:\n# just import one thing, don't pollute namespace\nfrom . import solvers\n\n...\n# ~150 lines in\n    if solve_strategy == \"entropy\"\n        # ah, this is one of many solvers in this\n        solver = solvers.EntropySolver()\n    elif solve_strategy == \"shannon\"\n        solver = solvers.ShannonSolver()\nOne slight drawback of this terse approach is you can end up shadowing the most intuitive variable name for a class instance with a module that has a similar name. I.e., if I rename my module pkg_solver -&gt; solver then I wonâ€™t be able to do from . import solver at the top and then later also say solver = solver.EntropySolver(), because the variable name solver representing my class instance will clobber the name in the namespace that represents my solver module. This will cause Pythonâ€™s head to explode (and yours). In this case I prefer to either use an absolute import internally, import pkg.solver, or to alias internally, e.g., from . import solver as solver_classes, so that an external user still can write something simple like pkg.solver.\n{:footnotes} *"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#you-should-know-sub-packages-exist",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#you-should-know-sub-packages-exist",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "You should know sub-packages exist",
    "text": "You should know sub-packages exist\nAgain, this is less about naming, and more about structuring internals. But it falls under the same category of â€œthing I see that tells me you might not yet have a mental model of how to organize your code to make it easier for you to maintain in the long runâ€.\nYou should know (if you donâ€™t already) that you can make a sub-package inside your package. You do this the same way you make the package itself, by adding the magical __init__.py file that tells Python â€œthis directory is a packageâ€.\nHere we add a solvers sub-package to the emgtoolkit package from our example.\nemgtoolkit\nâ”œâ”€â”€ solvers\nâ”‚Â Â  â”œâ”€â”€ __init__.py\nâ””â”€â”€ __init__.py\nHere is an example in the Python docs on modules: https://docs.python.org/3/tutorial/modules.html#packages\nGoing back to our example from above, we can refactor our (presumably gigantic) solver module into a handful of modules inside the solver sub-package:\nemgtoolkit\nâ”œâ”€â”€ load.py\nâ”œâ”€â”€ main.py\nâ”œâ”€â”€ simulate.py\nâ”œâ”€â”€ solvers\nâ”‚Â Â  â”œâ”€â”€ brute_force.py\nâ”‚Â Â  â”œâ”€â”€ entropy.py\nâ”‚Â Â  â”œâ”€â”€ gibson.py\nâ”‚Â Â  â”œâ”€â”€ __init__.py\nâ”‚Â Â  â”œâ”€â”€ random_walk.py\nâ”‚Â Â  â””â”€â”€ shannon.py\nâ”œâ”€â”€ timestamp.py\nâ””â”€â”€ __init__.py\nThen you can use imports so that, from the perspective of the user, they have access to the same modules with classes, functions, etc., that they had before. You do this by importing all the classes from each module in the sub-package inside the __init__.py of that sub-package.\n\"\"\"solver sub-package\"\"\"\n# this is __init__.py\nfrom .entropy_solver import EntropySolver\nfrom .shannon_solver ShannonSolver\nfrom .gibson_solver GibsonSolver\n...\nThis kind of looks like the thing I told you to not do above. But the difference here is that you are importing inside the __init__.py file, where (ideally) you are not hiding any functions; instead you are just doing some boring boilerplate imports here to make your life easier somewhere else. This lets you be more intentional about your API too. You can have some helper functions inside the sub-package modules that users donâ€™t really need. To broadcast to the world the stuff you think people need, you import just that stuff inside your sub-package __init__.py\n\nPython doesnâ€™t have a concept of â€œpublic and private members of objectsâ€, as languages like Java do, so thereâ€™s no (good) way for you to absolutely prevent someone from importing and accessing things. Instead Python follows the principle of â€œweâ€™re all adults hereâ€, and uses some conventions to indicate things like private and internal functions. See the section of PEP8 on naming, in particular, where it talks about _single_leading_underscore as a weak â€œinternal useâ€ indicator.\n\nThe other advantage of breaking code up into many modules within a subpackage, from your perspective as a maintainer, is that you can easily focus on one little chunk of code at a time. I promise that in the long run, this will help you, especially when you need to context switch and work on multiple things at once. Especially if thereâ€™s some helper functions and youâ€™re not having to scroll or jump around through 3000 lines of code to find them."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#finally-dont-name-a-module-package.utils-or-package.utilities",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#finally-dont-name-a-module-package.utils-or-package.utilities",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "Finally, donâ€™t name a module package.utils or package.utilities",
    "text": "Finally, donâ€™t name a module package.utils or package.utilities\nSomeone even more jaded than me has already said this: https://breadcrumbscollector.tech/stop-naming-your-python-modules-utils/\nThe basic idea is that the concept of utilities is so nebulous that more and more things will end up crammed into this module, that are less and less related to each other. This is especially likely if multiple people are developing a package, and they are tempted by the name utilities to add just one more helper or validation function inside that (now gigantic) module when trying to add a new feature.\nHold on, friend. Take a step back, take a deep breath. Itâ€™s okay to add a module with just a single function. You can just have a module named timestamp with only one function get_timestamp, and have it be only 10 lines. Please believe me, it will make the codebase easier to read, it will make internal usage of the function easier to read, it will make it easier to write quick unit tests. You do not want to hold 500 lines of utils in your head when youâ€™re trying to track down a bug. If you donâ€™t like that your top-level namespace gets cluttered by these little modules, than pull out our sub-package trick from above to push those modules down a level.\nSo thatâ€™s me saying what that other blog post said, after I said they already said it. All I want to add here is that the same logic from above applies: you want people to use your package. So give the modules very specific names so people know exactly what everything is doing. It will help your potential users and it will help future you."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#take-homes",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#take-homes",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "Take-homes",
    "text": "Take-homes\nAt the risk of repeating myself, let me tell you again why youâ€™d want to take these tips to heart. You want people to use your library that youâ€™re sharing with the world. Itâ€™s amazing; people can go onto the internet and just use the tools you put all that effort into! As a researcher, this is the kind of instant gratification you canâ€™t get when you are taking on the Herculean task of putting reality into a headlock with an experiment.\nSo make the most of it! Give your Python packages and modules names with just a few letters, and make use of imports and sub-packages to further structure the namespace of your package so that itâ€™s convenient to work with. This will also benefit you in the long run when youâ€™re working with your own code.\nSince Iâ€™m writing for research scientists, I will of course end the discussion by claiming that this blog sets the stage for future research. A good question would be, has anybody done any research supporting my claims that these tips will help you and others read and use your code? If I ever finish reading The Programmerâ€™s Brain, Iâ€™ll probably be able to tell you. Stay tuned for another post. ğŸ™‚"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#footnotes",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#footnotes",
    "title": "Four tips for structuring your research groupâ€™s Python packages",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee similar comments from core Python dev Brett Cannon in this post, https://snarky.ca/if-i-were-designing-imort-from-scratch/ in the section â€œYou can only import modulesâ€.â†©ï¸"
  }
]