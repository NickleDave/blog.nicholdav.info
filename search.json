[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hoping machine",
    "section": "",
    "text": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024\n\n\n\n\n\n\nmusic\n\n\ntech\n\n\n\nMusic I bought on Bandcamp this year, and why\n\n\n\n\n\nJan 5, 2025\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nDomain-driven software design is a good idea, still\n\n\n\n\n\n\ndomain-driven design\n\n\ncomputer science\n\n\nresearch software engineering\n\n\n\nDomain-driven design might be just data abstraction with doodles, but you should care about it anyways\n\n\n\n\n\nJan 2, 2025\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nFour tips for structuring your research group‚Äôs Python packages\n\n\n\n\n\n\nresearch software engineering\n\n\nPython\n\n\n\nHow to structure your Python package so other researchers want to use it\n\n\n\n\n\nDec 26, 2022\n\n\nDavid Nicholson\n\n\n\n\n\n\n\n\n\n\n\n\nMake your own academicpages site from scratch with jekyll\n\n\n\n\n\n\nacademia\n\n\n\nInstead of forking academicpages, make it yourself to better understand jekyll\n\n\n\n\n\nMar 16, 2022\n\n\nDavid Nicholson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html",
    "href": "posts/2025-01-02-domain-driven-design/index.html",
    "title": "Domain-driven software design is a good idea, still",
    "section": "",
    "text": "This post falls in the category of ‚Äúme writing about how my thinking has evolved about research and software‚Äù. If you are a researcher that writes software, then you might get something out of it. Especially if you‚Äôre not familiar with the idea of domain-driven design. What I hope to convince you of is that, sure, domain-driven design is just as obvious an idea as it sounds, but you should still be thinking about it. I‚Äôll get there by saying a little about one book I‚Äôve been reading recently, Structure and Interpretation of Computer Programs."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#what-is-domain-driven-design",
    "href": "posts/2025-01-02-domain-driven-design/index.html#what-is-domain-driven-design",
    "title": "Domain-driven software design is a good idea, still",
    "section": "What is domain-driven design?",
    "text": "What is domain-driven design?\nBut first, let me introduce domain-driven design, and tell you why you might care about it. Sometime in 2022-2023, I read Domain-Driven Design by Eric Evans, and I got really excited about it. (You can get it from bookshop.org here, and if you‚Äôre feeling dangerous you can probably find a PDF of it on a random GitHub repository.) I ended up reading it because I had been reading Architecture Patterns with Python, and they mentioned it in the introduction. Full disclosure: I have not finished either of these books. In fact, I haven‚Äôt finished a lot of books, but that‚Äôs maybe the undiagnosed ADHD talking. I did spend a lot of time with the first few chapters of both, though. If you do nothing else, read the first chapter of Evans‚Äô book, where he relates the story of how he worked with some electrical engineers to design software they would use to design printed circuit boards (AKA PCBs). If you have ever gone through the process of designing software for some real-world domain, I bet it will really resonate with you. Or, you know what? I‚Äôll dare to say that, even if you have only ever written nerdy software tools for the domain of other software nerds, you still might find that the story resonates with you. It‚Äôs an interesting story for a couple of reasons. First of all, you have a feeling that he is almost an anthropologist, going into this unfamiliar tribe of electrical engineers so he can learn their culture. I think this is a familiar feeling for anyone who has tried to translate some real-world domain into software, even if it‚Äôs part of a culture they feel like they belong to. Second, you really get a feel for his process. At the beginning, he makes mistakes. He tries to understand their jargon word-for-word. Then he asks them to specify in detail what they think the software should do. Neither of those approaches were ever going to work well. Finally he hits upon the idea of asking them to draw out diagrams of their process and how the software should interact with it. These are simple, rough box and arrow sketches as he shows.\n\n\n\nevans figure 1.2\n\n\nI happened to read this at the same time that I had been sketching out some initial ideas for the VocalPy library that I develop. You can see some of these sketches here: https://github.com/vocalpy/vocalpy/issues/19\n\n\n\nschematic of library named vocles from linked github issue\n\n\nIf you were to click through to the library‚Äôs docs, you might notice that these bear little resemblance to VocalPy now. I think this is actually a good thing ‚Äì more on that below. (You might also notice at the time I was thinking of calling it vocles ü§¶ ‚Äì this is a very tortured pun, everyone please clap for me showing enough restraint for once in my life to not deploy a tortured pun.)\nI don‚Äôt actually remember which came first: these sketches, or me reading the book. I think that I actually drew the sketches first, and had them sitting around on a desk forever, until finally it hit me that I should add them to the repo to document my design process. And then reading this part of Evans‚Äô book really made me think that drawings like this should be integral to the design process. Part of what I want to say here is that, you should be doing this, if you‚Äôre not already, and what‚Äôs more, you should be including it in your docs for your software. And this goes for all software, unless you are literally writing such a boring cookiecutter CRUD app that a so-called Large Language Model can regurgitate it perfectly for you after being ‚Äútrained‚Äù on the actual work of human beings.\nAt this point, you might be thinking, ‚Äúwrite code in terms of your domain, yeah, sure, everybody does that‚Äù. Like I said, I got really excited reading this stuff and told people about it at the job I had at the time. I made a big deal of presenting parts of the book, and talking about how we could use this approach for what we were working on. And I got this very underwhelmed response of ‚ÄúYeah, we sort of already do that. Aren‚Äôt you just describing object-oriented programming?‚Äù Yes, but no! I‚Äôll come back to the ‚Äúno, we aren‚Äôt doing that below‚Äù, but first, the yes. We should realize this is what we‚Äôre already doing and be very explicit about it! The domain should be at the front of our mind at all times, and we only should be iterating on the design of our software insofar as it relates to the domain!\nHere I‚Äôll say what I said in that work meeting when I got that underwhelmed response: domain-driven development isn‚Äôt just thinking about the domain. Even though we all sort of subconsciously think of the domain when we design our code, Evans advocates for a specific development process, that he says is required for his approach to design to work. The important part here is that he sees his process as a form of extreme or Agile programming. If you don‚Äôt know what those are, what you need to know is that they are more iterative then previous approaches based on ‚Äúelaborate development methodologies that burden projects with useless, static documents and obsessive upfront planning and design‚Äù, as he puts it. Instead, Evans focuses on writing code that has a bare bones implementation he can test right away. ‚ÄúDevelopment is iterative.‚Äù Of course, this is one place where Python, my main programming language, shines. It‚Äôs really easy to iterate interactively in a Jupyter notebook with a bare-bones implementation of your sketch of an API. Of course, later you should do some proper engineering instead of living in Jupyter notebooks, so you don‚Äôt have to worry about someone giving a preachy lecture in the form of a conference talk that condemns you for your naughty programming practices. His other requirement for the development process is that ‚Äú[d]evelopers and domain experts have a close relationship.‚Äù If you are a researcher who programs, well, hopefully you already have a close relationship with yourself. And with your collaborators and colleagues. This second requirement naturally gives rise to one of the key ideas from the book, that of ubiquitous language. This is a sort of pidgin language that the domain experts and software developers arrive at together through the iterative process of development. The words in this ubiquitous language correspond to key concepts in the domain that the software needs to capture, the things that developers and domain-experts realize they should focus on, as they iterate. Ubiquitous language ‚Äúembeds domain terminology in the software systems we build‚Äù, as Martin Fowler puts it in this post. It‚Äôs this continous process of developer and domain expert iterating together that really appeals to me."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#how-ive-used-domain-driven-design",
    "href": "posts/2025-01-02-domain-driven-design/index.html#how-ive-used-domain-driven-design",
    "title": "Domain-driven software design is a good idea, still",
    "section": "How I‚Äôve used domain-driven design",
    "text": "How I‚Äôve used domain-driven design\nOk, now you have an idea of what domain-driven design is. You might ask yourself, have I done anything with this or do I just like pontificating into the void about ideas from computer science and tech books? Even if I haven‚Äôt gone back to finish the book and immerse myself in every detail, the core idea has really stuck with me. So much so that you can see that I cited the book in the Proceedings paper where I first introduced VocalPy, and where I included similar schematics.\n\n\n\nfigure 1 from VocalPy proceedings paper\n\n\nAs I mentioned above, even by the time I got to this first Proceeding paper, the design of the library had evolved. But this is a good thing ‚Äî I did exactly what Evans prescribed, and continued to iterate on the design of the package. Doing so made me realized which parts were actually useful, that I wanted to retain in the core. I think sketching things out has also helped me understand why the things I ended up taking out are still useful, just not in the way I had thought at first. The library at first was very focused on the idea of capturing a dataset of specific file types, and then being able to save this dataset in the form of a SQLite file. You can see where I was really focused on treating the dataset as if it were part of an app, like in the architecture book. I do think this is still important, but it is not the core of what the library does ‚Äì I realized later that the core data types needed to be things like sounds, spectrograms, annotations, the things that a researcher studying animal communication and using bioacoustics would be talking about. So, basically, I did the anthropological exercise, as in Chapter 1 of Evans‚Äô book, but instead of doing it with other people, I started by doing it with the part of my brain that claims to know things about acoustic communication. (I have since engaged with other people who actually know these things and can give me good feedback.)\nI also came back to the idea of domain-driven development in a talk I gave about VocalPy where I talked a little bit about how it maybe clashes with some recommendations for programming in scientific Python."
  },
  {
    "objectID": "posts/2025-01-02-domain-driven-design/index.html#domain-driven-design-is-just-data-abstraction-with-doodles-and-you-should-do-it-anyway",
    "href": "posts/2025-01-02-domain-driven-design/index.html#domain-driven-design-is-just-data-abstraction-with-doodles-and-you-should-do-it-anyway",
    "title": "Domain-driven software design is a good idea, still",
    "section": "Domain-driven design is just data abstraction with doodles, and you should do it anyway",
    "text": "Domain-driven design is just data abstraction with doodles, and you should do it anyway\nOk, so now let me circle back around, talk about why, sure, domain-driven design is not a new idea (as Evans himself acknowledges right at the start of his book), and why you should be doing it, or doing even more of it. This is where I come back to the ‚Äúno‚Äù part of ‚ÄúDo we already do this? Yes and no.‚Äù In the discussion at the end of that talk, I said just what I‚Äôve said here, that a lot of people react as if, ‚Äúso, yeah, we already do that‚Äù. If that‚Äôs so, then show me the doodles! Show me your mental model of your domain ‚Äî put it in your docs! Let me read it, let me actually see these schematics, even if they are just doodles, it helps me to know how your thought process evolved. All I can see right now is this insurmountable mountain of code, and I don‚Äôt even know where the path starts so I can scale it! I know that there are examples of people doing this, e.g., in the scientific Python community where I spend most of my time, but I think it‚Äôs fair to say that this is not the norm. I don‚Äôt know that I have ever seen diagrams showing how the design evolved, as part of an iterative development process. I can‚Äôt help but feel like that‚Äôs exactly the sort of thing that could help people get up to speed on how the code works.\nAnd now the moral of the story at the end. I now know for sure that these ideas have been around longer than Eric Evans‚Äô book, because I have been attempting to read yet another book, the aforementioned Structure and Interpretation of Computer Programs (AKA ‚ÄúSICP‚Äù, and I am reading the Javascript edition, if you even care). I ended up reading this book because I have begun working my way through the reading list on teachyourselfcs.com. That is another topic that could be a blog post unto itself, but suffice to say that it is a source of some shame that I ostensibly make my living by programming computers, but I only have the vaguest idea of how computers work, or how programming works, and so I have this need to fix that. I have also realized that, of course, computer scientists also think in terms of models of computers, that is, their domain, and this is why it‚Äôs easier to learn about computers by learning their models. This is why it‚Äôs helpful to learn git by actually learning how git works as others have noted, and this is why I think it has actually been worth reading SICP, because it gives me two or three different mental models of how computer programs work. Again, maybe its old news to you, but I feel like I really need a reminder that we constantly build and then throw away scratch models of whatever we‚Äôre working on, and this includes stuff we do with computers. Given that SICP has the nickname ‚ÄúThe Wizard Book‚Äù, I can‚Äôt be the only one who falls into this way of thinking‚Äî that programming is modern sorcery, and I should sit before the blank screen like a cyberpunk Zeus and have the program emerge fully-formed from my forehead. (I am mixing Greek mythology and wizardy in my metaphors. Whatever, you get the point.)\nThis is how I ended up finding domain-driven design in SICP, and having to admit to myself that, yeah, this idea has been around forever. Lo and behold, when I got to chapters 2 and 3, there I saw that we were talking about data abstraction and designing programs for modeling. Sound familiar? Let me quote you this bit from chapter 3:\n\nOne powerful design strategy, which is particularly appropriate to the construction of programs for modeling physical systems, is to base the structure of our programs on the structure of the system being modeled. For each object in the system, we construct a corresponding computational object. For each system action, we define a symbolic operation in our computational model. Our hope in using this strategy is that extending the model to accommodate new objects or new actions will require no strategic changes to the program, only the addition of the new symbolic analogs of those objects or actions. If we have been successful in our system organization, then to add a new feature or debug an old one we will have to work on only a localized part of the system.\n\nWell there it is, domain-driven design in a nutshell. And if so great and venerable a source as SICP deigns to talk about it, if these supposedly very smart people think it‚Äôs worth discussing in the introductory sections of their book chapters, then it must be an idea worth thinking about. QED."
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "",
    "text": "In this post I‚Äôm sharing music I bought on Bandcamp in 2024. I‚Äôll also say a little bit about the interaction of music and the tech industry in general: apps like Spotify, Bandcamp, and YouTube; how they affect artists and how they affect our listening habits. I‚Äôve working on a couple follow-up posts. Those are about how I feel like we‚Äôre getting close to having the tools for musicians and listeners to reclaim ownership of their music. So consider this post a prelude to those.\nEvery December, Spotify rewards us for submitting to their algorithm by giving us our Spotify Wrapped. Their Wrapped tells us which artist we spent the most time with, what song topped our playlists, how many minutes we listened.\nI barely use Spotify. My Wrapped was basically ‚ÄúYou listened to Tame Impala Radio 10 times in August‚Äù.\nI just got into Tame Impala, don‚Äôt judge me. You can see my fifth most listened too song was a song I listened to maybe twice from a French Canadian artist that my friend Alex introduced me too (that‚Äôs foreshadowing for later).\nBut I love to see people share their Wrapped on Bluesky and Twitter, especially if ironic. ‚ÄúYes, I am in the top 0.01% of Gwar fans.‚Äù\nI want my own Wrapped! I want to tell a story about what I did this year, kind of like a tech blogger making a listicle of their annual achievements. But I want to receive it passively from the app I listen to music on, instead of me writing a blog post. (Wait a second.)\nThankfully, my good friend Alex Chabot-Leclerc knows that I buy a lot of music through Bandcamp.\nAnd that‚Äôs why he shared this cool blog post with me from Mac Wright, on how to generate a Bandcamp Wrapped, with an app that Wright has on val.town:\nhttps://macwright.com/2024/12/06/bandcamp-wrapped.html.\nThe actual app on val.town is here: https://tmcw-bandcampwrapped.web.val.run/\nI think Alex is a big fan of Wright‚Äôs work. And like me, Alex is really into music, and posts about it weekly on his blog: https://alexchabot.net/categories/music/\nHe shares Spotify links and playlists, and that works great (I will begrudgingly admit that there are some good things about tech).\nBut for those of us that buy a lot of music on Bandcamp, we can now generate our own Wrapped, thanks to Mac."
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#is-bandcamp-itself-wrapped",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#is-bandcamp-itself-wrapped",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "Is Bandcamp Itself Wrapped?",
    "text": "Is Bandcamp Itself Wrapped?\nIn his Bandcamp Wrapped blog post, Mac links to his own previous writing about his ‚Äúprepper-style music hoarding‚Äù. To quote him, ‚ÄúI don‚Äôt believe that any technology company in the music industry will survive in the long term.‚Äù You should read what he has to say, but let me tell why I buy a lot of music on Bandcamp, since I‚Äôm here writing a whole post about it.\nI am a huge music fan. I wanted to be a musician, once. So I am painfully aware that the tech industry I now work in has really changed how musicians make money. It used to be that record companies could support a relatively broad base of musicians, as long as those musicians helped them sell enough sounds etched into highly processed dinosaur bones (i.e., records). Now we have replaced that system with a new one, where tech overlords support a much narrower base of musicians, almost by accident, since they pay only thousandths of a penny every time a song gets streamed. I think somebody wrote a pretty good song about it once.\n\n\n(You can‚Äôt read the rest of this blog post until you sit through the whole song. My blog, my rules üòé)\nOf course the right fix for this is to not actually change the system, but instead to make each person feel like they alone are personally responsible for fixing everything. And that is why, whenever I can, I pay for music through Bandcamp. Individualism! Exceptionalism! Americanism! The Bandcamp business model lets me put my money where my mouth is, because it gives artists and labels a lot of control over how they sell music: what prices they set, what merchandise they sell, and so on. This seemed like a good way to vote with my dollars for an alternative to streaming platforms like Spotify. Until Bandcamp was acquired by Epic Games, and then by Songtradr, who layed off half the staff. Perhaps not surprisingly, this was around the same time that Bandcamp workers were trying to unionize. So much for ‚Äúchampioning independent artists‚Äù. So much for me personally fixing everything.\nOk, the angry tech bros of the broligarchy are telling themselves I‚Äôm just virtue-signaling with this whole little section about how I basically deserve a Nobel prize for the amount of money I‚Äôve given to artists through Bandcamp. The last thing I‚Äôll say, before I actually write about music, is that I have seen a couple of attempts to build worker-owned platforms. In principle, I am totally in favor of this. We do not need our feudal tech overlords, and the sooner we realize it the better. But in practice, there‚Äôs some complicated economics game theory going on when you have multiple companies, each running on a shoelace budget, all trying to replace the platform run by the tech barons, who have infinite money to fend them off. Still it‚Äôs worth knowing about these efforts. Someone who is smarter than me made this great website that sums up what‚Äôs been done: https://bandcampalternative.com/"
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#more-like-youtube-wrapped-2020-2024",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#more-like-youtube-wrapped-2020-2024",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "More like Youtube Wrapped 2020-2024",
    "text": "More like Youtube Wrapped 2020-2024\nI will mostly shut up about tech now, and mainly write about music.\nI did as Mac‚Äôs tool instructs, copying and pasting my Bandcamp purchases from 2024. That gave me a big list in HTML. Instead of just dumping the output here, I decided to write about the music I‚Äôve been into over the last year, and how I found it. But it turns out this blog post will be way too long if I write about all the music I bought on Bandcamp this year ([virtue signaling intensifies]). So I‚Äôll talk about something more interesting: how do I replace Spotify‚Äôs recommendations? I can pay artists directly, I can make my own Spotify wrapped, but how do I find new music? It turns out, mostly YouTube, but also recommendations from friends. Let‚Äôs talk about each in turn.\n\nI was radicalized by YouTube ambient playlists\nI have been into ambient for a while. Like a lot of people, I was unwittingly turned on to Japanese ambient during the pandemic, thanks to the YouTube algorithm. See this article on ars technica: https://arstechnica.com/gaming/2020/11/how-old-ambient-japanese-music-became-a-smash-hit-on-youtube/ (I like a lot of the related music namechecked in this article, that was also mysteriously promoted by the YouTube algorithm, like 1979 from Deru, Plant Music, and An Empty Bliss Beyond this World by the Caretaker)\nLooking back over this year, The Algorithm has continued to turn me on to a lot of other ambient, but more into the genre of spacemusic. Somehow this sci-fi ambient fits with the rest of my media diet: I played a lot of post-apocalpytic roguelike Caves of Qud this year and I re-read the first book of the post-apocalpytic Southern Reach Trilogy.\n\nUK ambient\n\n\nNACHT MUSIK by Steve Brenner\n\n\nDARK HOUR Brenner/Gulch by STEVE BRENNER\n\n\nS I G N A L S by STEVE BRENNER\n\n\nTwelve Dimensional World by Tim Stebbing\n\n\nOrbiter by Tim Stebbing\n\n\nBoth Steve Brenner and Tim Stebbing I think are UK artists who got their start in the ~70s. I found them through YouTube channels like Sounds of the Dawn, here and here. Side note: Brenner has directly sent me a (brief!) email every time I‚Äôve purchased from him. This is the kind of personal touch you don‚Äôt get when you stream music through a Platform.\n\n\nAmerican Primitive ambient\nOk, there‚Äôs only one group in this category, the Nightcrawlers, but I love them, and I wish I could pay them more for all of their music. I don‚Äôt know if they already have their own microgenre but I‚Äôm going to call it ‚ÄúAmerican Primitive ambient‚Äù.\n\n\nThe Biophonic Boombox Recordings by The Nightcrawlers\n\n\nI found them through this channel: https://www.youtube.com/watch?v=qkmsWKKPVvo But as that person kindly pointed out there‚Äôs actually another channel with a whole playlist.\n\n\nWhat I really love about their albums are the art, clearly made on some 80s graphic design software like Printshop, but somehow managing to have a mysticisim at the same time.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThey have a mysticisim in the same way that I think Robert Pollard‚Äôs lyrics about UFOs and his collage album covers are, at their best, mystical.\n\n\n(I know, as of that last sentence I‚Äôm really blurring the line between tech blog and annoying album review guys on YouTube. Bro, I contain multitudes.)\n\n\nModular?\nOne last bit of ambient music, two groups that I will lump into another totally-made up microgenre I‚Äôll call ‚Äú80s american ambient‚Äù, since there‚Äôs no overt themes of space per se.\n\nYoung Scientist\nThe first group is named Young Scientist, and with a name like that of course I have to like them. I‚Äôm no longer so young, but I do feel like they really have made scientist soundtrack music, that conjures up late hours in the lab. Yes, I found them through YouTube.\n\n\nOver Low Trees‚Ä¶ by Young Scientist\n\n\nResults, Not Answers by Young Scientist\n\n\n\n\nSines of Exquisite Pleasure\nThe second group is Sines of Modular Pleasure. Again, yes, I found them through YouTube.\nThere‚Äôs some question of whether they are even ‚Äúreal‚Äù, in the sense of really old, or whether it‚Äôs more of a tribute group making music in the present day. Check out this maniac‚Äôs blog post: https://ivandsm.github.io/2022/12/04/on-sines-of-exquisite-pleasure.html (Maniac in a good way, thank you for your work, whoever you are.) Based on their latest release, I think they are indeed more of an homage. It still works for me, and I would still lump it into this category of sounding like ‚ÄúAmerican suburban guys who wanted to be Brian Eno or Tangerine Dream but had to re-invent the genre from scratch‚Äù.\n\n\nAlaska by Sines of Exquisite Pleasure\n\n\nStudies in Luminescence by Sines of Exquisite Pleasure\n\n\nModular Systems by Sines of Exquisite Pleasure\n\n\nMusic for Hospitals by Sines of Exquisite Pleasure\n\n\n\n\nCube of the Unknowing\nYet another YouTube find.\nAgain, as a scientist who would like to resist all the worst aspects of reductionism, how am I not going to like an album called Ghost Circuits of Menlo Park?\n\n\nGhost Circuits Menlo by The Cube of Unknowing\n\n\nBog Phosphors by The Cube Of Unknowing\n\n\n\n\n\n\nElectronica\n\nHotel Pools\nHotel Pools is another artist I found during the pandemic. I think probably through YouTube ‚Äî although this might be one case where I found the artist from other people‚Äôs Bandcamp profiles? This was my running music, when I would do my routes through Rock Creek Park in DC. It‚Äôs perfect for that. Just total shut-off-worry-noise-thoughts music. So I had to get their new album this year.\n\n\nFiLo by Hotel Pools\n\n\n\n\nHome\nYet another group I found through YouTube this year, this time as the first song on this random playlist that features a mecha-Bart Simpson as the image with a trippy bad VR background.\n\n\nYou‚Äôre telling me that you do not feel goosebumps all over your body, as if a your soul became a laser beam shooting out of God‚Äôs forehead, at the very moment you hear that first song, with the mecha-Bart and the cyberpunk background undulating behind? You, sir, have no soul.\nTurns out all their other shit is really good too.\n\n\nFalling Into Place by HOME\n\n\nResting State by HOME\n\n\nBefore The Night by HOME\n\n\n\n\n\nOther\nOkay, we‚Äôre mostly going to leave ambient and electronica behind now, but we‚Äôre still talking about music I learned about through YouTube.\n\nHehehehe\nYou guessed it. The YouTube algorithm found me with this one.\n\n\nd√©j√† vu, sonder by Hehehehe\n\n\n\n\nPiero Umiliani\nThe YouTube algorithm has also turned me on to library music and film scores. I feel kind of gross putting some of these album covers in a blog post, but, man, this music is so good. Hot take: literally some of the best music in the last century was composed for trashy Italian movies.\n\n\nIl Corpo by Piero Umiliani\n\n\nPianoFender Blues by Piero Umiliani\n\n\n\n\nShannon Lay\nI first got into Shannon Lay after hearing her cover on Karen Dalton‚Äôs ‚ÄúSomething on Your Mind‚Äù. That‚Äôs right, I found her cover on YouTube.\n\n\nGeist by Shannon Lay\n\n\n\n\nNihls Frahm\nThe YouTube Algorithm definitely got me into Frahm, at about the same time it was recommending Harold Budd. Budd is definitely on the ambient side, Frahm can venture into Radiohead-like pop-electronica on some albums.\n\n\nDay by Nils Frahm\n\n\n\n\nGabor Szabo\nOk, finally, the last of the music that I found on YouTube. At the same time I was getting into Italian composers like Umiliani and Piero Piccioni, the Algorithm played this guitar album for me. I can‚Äôt say why it moves me so much, Szabo‚Äôs playing and this album in particular are almost unclassifiable in terms of genre. He is totally uninterested in anything poppy here, or even jazzy, at least in the sense of American jazz. When I realized this year that the album was on Bandcamp, I had to get it.\n\n\nDreams by Gabor Szabo\n\n\n\n\nMy Alex Chabot-Leclerc Wrapped 2024\nThe other way I find music is through friends of course. Since my friend Alex inspired this post, I would be remiss if I didn‚Äôt include the music I bought from his home of Canada this year. I promise I have at least one other friend, but I promise I am trying to keep this post somewhat short. So, let‚Äôs just talk about what Alex recommended to me.\n\n\nTop Minou by Bleu Jeans Bleu\n\n\nL‚Äôappartement by ludovic alarie\n\n\n√Ä demain peut-√™tre by Galaxie\n\n\nAqualudes by Am√©lie Fortin\n\n\nHe introduced me to Bleu Jeans Bleu a couple of years ago. Primo quality rock/pop with a distinctly Quebecois flair. Alex told me one of their songs perfectly captures the feeling of being in Quebec for him. You might mistake them for a novelty group, ironically parodying\nSee for example,\n\n\nThe L‚Äôappartment album I found while in Maine for the NMAC 2024 conference. I was sitting in the parking lot of the hotel the conference was at, and this song came on the radio, on this French Canadian station I had managed to pick up. It was just a very nice vibe, made even more nice by the slight patina of static from the almost out of range station. I loved the song so much I ran inside to google and try and figure out what station it must be, so I could see if they had a playlist. Like a total weirdo, I was even asking people at the conference I knew who happend to be from Canada if they knew of the stations. No, what is wrong with you. I found the station anyway, and they did have a playlist.\nI liked the band so much I had to ask Alex if he knew of them; he did not, but the name rang a bell, and in fact this musician is the son of another musician Alex is familiar with. Not surprisingly, Alex suggested some other musicians in the same vein, like Amelie Fortin. And then later in the year he happened to recommend Galaxie, that definitely hit that alternative rock spot in a way I haven‚Äôt heard in a while."
  },
  {
    "objectID": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#next-time",
    "href": "posts/2025-01-05-bandcamp-wrapped-2024/index.html#next-time",
    "title": "My Bandcamp-YouTube-Spotify-friends Wrapped 2024",
    "section": "Next time",
    "text": "Next time\nIf you made it through all this music, thank you for your attention. As soon as I add those other posts about reclaiming ownership of music, I will link them here."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "",
    "text": "Update 2025-01-08: I switched to quarto, but I refuse to write a blog post about it.\nUpdate 2022-12-17: I added a home page and a blog to my site, so I no longer use a set up exactly like the academicpages theme, but I‚Äôm leaving this post up to document the process (and because it‚Äôs currently my only post üò≠)\nIn this post I document the process I went through to set up a peronsal web site with a structure similar to the academicpages theme used by many academics (https://academicpages.github.io/). I‚Äôm writing the post for my future self, and for you if you want to do the same."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô",
    "text": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô\nHere‚Äôs the summary version first, so you know what you‚Äôre getting into: 1. set up a jekyll development environment 2. make the landing page be your about page 3. make the sidebar show your profile with links 4. add links to publications, talks, etc., in the nav bar at the top of the page"
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#why-would-you-bother",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#why-would-you-bother",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Why would you bother?",
    "text": "Why would you bother?\nI wanted a site similar in style to academicpages (https://academicpages.github.io/), with links in the sidebar to Google Scholar, OrcID, etc., and the ability to use jekyll‚Äôs ‚Äúcollections‚Äù feature to easily organize publications, talks and teaching. But I also wanted the flexibility to change themes, which is not easy to do with academicpages.\nIf you‚Äôre like me, and you mainly write code in Python, you might naturally use a static site generator written in Python (as I did for a while, see next section). Using jekyll, that‚Äôs written in Ruby, might feel like a big jump‚Äì the big pain point in switching languages is often getting familiar with their tooling. As a Pythonista, of course I want to support Python libraries, and some of the static site generators like pelican are battle tested with themes that are very versatile, like their version of bootstrap. But somehow minimal-mistakes and other jekyll themes just look better to my (untrained) eye.\nAnd as a programmar and developer, it might be a fun exercise in using libraries in a language besides Python. It‚Äôs interesting to experience the tooling in the ecosystems of other programming languages."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#how-did-we-get-here",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#how-did-we-get-here",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "How did we get here?",
    "text": "How did we get here?\nI‚Äôve had a personal web page for sometime that I set up with pelican, a static web page generator in Python. Basically I adopted my approach from the one Jake Vanderplas took for his ‚Äúpythonic perambulations‚Äù blog. However I wasn‚Äôt happy with how my page looked (which has nothing to do with Jake Vanderplas, and everything to do with my moribund graphic design and css/html skillz). And it was time to update my site anyway. Recently I noticed a collaborator had set up their own personal site using the excellent academicpages repository, developed by Stuart Geiger. academicpages is great if you are trying to survive in academia and you don‚Äôt have time to bother learning how to use a static site generator. With academicpages you just want to follow a couple steps to add your own content to some existing template, to easily get a site.\nSome background: academicpages is a fork of minimal-mistakes, a very popular theme for the jekyll library. jekyyl is a static site generator written in the ruby programming language. You can think of it as analogous to pelican in Python (or Ruby developers might tell me that pelican is analgous to jekyll). One advantage of using jekyll is that GitHub really likes jekyll, letting developers easily create web pages for themselves or documentation for their projects through the GitHub Pages service. And it‚Äôs free, another plus for academics. Stuart modified the minimal-mistakes theme in such a way that other academics could simply fork its repo on GitHub and use the web interface to add their own content, without needing to know how to use jekyll or how to use any developer tools like git.\nSo I knew I wanted a site like academicpages, but I also knew there were things I wanted to modify, such as the theme / template. There‚Äôs little documentation in the academicpages guide about what changes were made to the minimal-mistakes theme, and why. How did Stuart evolve the template from your standard jekyll minimal blog page to a very specific set-up for academics? Unique features of academicpages include that it lands on the about page and shows a profile in the sidebar with links to academia specific sites, and includes tabs like ‚Äúpublications‚Äù, ‚Äútalks‚Äù, etc.? I tried looking at the git commit history but couldn‚Äôt piece it together. I figured there couldn‚Äôt be too too many steps to setting up a similar site on my own."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages-1",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#step-by-step-guide-to-developing-your-own-academicpages-1",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô",
    "text": "Step-by-step guide to developing your own ‚Äòacademicpages‚Äô\nAgain, here‚Äôs the outline of what we‚Äôre going to do: 1. set up a jekyll development environment 2. make the landing page be your about page 3. make the sidebar show your profile with links 4. add links to publications, talks, etc., in the nav bar at the top of the page\n\nSetting up a development environment\nThis is a thing that might be new to academics not familiar with software engineering, but the jekyll and ruby devs have worked really hard to make it easy.\n\nset up a basic environment for working with jekyll\n\ntheir quickstart is here: https://jekyllrb.com/docs/\nI‚Äôm on PopOS, a Linux distribution similar to Ubuntu, and I use oh-my-zsh, so I followed these instructions: https://jekyllrb.com/docs/installation/ubuntu/ except I changed .bashrc to .zshrc\n\nthen I followed the directions for managing dependencies with bundler so that I could install the minimal-mistakes template as a gem instead of forking their repo and modifying it\n\nhttps://jekyllrb.com/tutorials/using-jekyll-with-bundler\n\n\n\n\nMaking the ‚Äúlanding page‚Äù be your ‚Äúabout‚Äù page\nThis is the first thing that‚Äôs specific to our site design.\n\nuse the redirect plugin so that the site lands on ‚Äúabout‚Äù\nadd an about.md ‚Äì make sure you copy the YAML front matter from academicpages\nmake sure _config.yml specifies defaults for pages so that your theme gets applied to this about.md file\n\nI copied the #defaults section from the academicpages _config.yml\n\n\n\n\nMaking the sidebar show your profile, with links\nNow we‚Äôre cooking with academicpages gas! Or something\n\nto make the author profile in the sidebar render all the links that are in academicpages but not in minimal-mistakes, i.e.¬†academia specific things like a Google Scholar page, ORCID profile, etc., you‚Äôll need to add an author-profile.html in an _includes directory. Basically I copied the author-profile.html from minimal-mistakes and then added the relevant if-then statements in the author-links section.\nfor things like an author pic, I added them in assets/images/ ‚Äì I think this is consider ‚Äúidiomatic Jekyll‚Äù even though the academicpages repo just has an images folder in its root. Doesn‚Äôt matter too much as long as you specify the correct relative path in your _config.yml\n\n\n\nAdding links to publications, talks, etc., in the masthead nav bar\nUnique to academicpages are the links in the navigation bar at the top of the page to pages with lists of publications, talks, and so on.\nIf you want the same thing, there‚Äôs two things you‚Äôll need to do: 1. you‚Äôll need to copy the ‚Äònavigation.yml‚Äô file from academicpages, placing it in a data/ subfolder in your project root, and modify it as you see fit. 2. add two related sections in your _config.yml: + a ‚Äòcollections‚Äô section, like this one in the academicpages _config.yml. + and corresponding keys in your defaults section as shown here in the academicpages _config.yml.\nThis is explained very briefly in the about.md of academicpages but here‚Äôs a quick explainer of how it all works. minimal-mistakes lets you add links to the masthead by supplying a file called navigation.yml. This is a standard approach in jekyll. There are other uses for data files. What‚Äôs specific to minimal-mistakes is that you add these links to the nav bar by specifying a main key in navigation.yml, as described here: https://mmistakes.github.io/minimal-mistakes/docs/navigation/. In the case of academicpages, the links have the names of the specific sections in the navigation.yml with the keys ‚Äúpublications‚Äù, ‚Äútalks‚Äù, etc."
  },
  {
    "objectID": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#coda-publishing-etc.",
    "href": "posts/2022-03-16-how-to-jekyll-academic-website/index.html#coda-publishing-etc.",
    "title": "Make your own academicpages site from scratch with jekyll",
    "section": "Coda: publishing, etc.",
    "text": "Coda: publishing, etc.\nAfter making the changes just described, I had a site with a structure similar to academicpages.\nTo actually publish the site, I still use a workflow similar to what Jake Vanderplas uses for his blog: https://github.com/jakevdp/jakevdp.github.io-source This centers around a Makefile with commands for build and serve.\nThe key thing that makes it easy to publish to Github Pages is to use the ghp-import package, as suggested by the pelican docs: https://docs.getpelican.com/en/latest/tips.html#project-pages. Of course, jekyll gets special treatment on GitHub so it‚Äôs kind of overkill, but I still like having a separate repo that I just push the .html and .css files to without thinking about it.\nSo this is how I have my site set up now! Stay tuned for it to change suddenly, because as a developer I love to spend hours farting around with tools that let me avoid real work. I‚Äôll keep this post up for posterity anyway."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "",
    "text": "Update 2025-01-08:\nI think this post gives better advice overall on designing a Python library API:\nhttps://benhoyt.com/writings/python-api-design/\nYou should read that one first, then come back and read this one for some examples of what not to do.\nThis is one of those petulant posts from someone who writes software. A post from one of those people that describes some library they wrote as ‚Äúopinionated‚Äù, as if the rest of us have been living in fear of expressing our opinions through software.\nSo, sorry in advance. But I want to talk about some things I see a lot in Python packages shared by research groups.\nAt the highest level, there‚Äôs two things I see: one, researchers name their modules in a way that might make sense when you‚Äôre writing your own code, but can seem very verbose or non-intuitive when you are someone else on the outside reading or using that code. Two, I see a lot of code that doesn‚Äôt structure itself in a way that makes it easier for people to read it and to use it. And you‚Äôre sharing your code because you want people to use it, right?\nI think a lot of packages from research labs end up this way in part because researchers don‚Äôt have a good mental model of the mapping from their written code to the package they import. In other words, they don‚Äôt have a clear picture of how Python translates the directory structure of their code and its internal import statements into a package name with modules that can be accessed with the dot operator, like so: package.subpackage.module.function.\nTo use a technical term, the code does not fully leverage its own namespace, the literal mapping from names of things in the package to the functions and classes that they refer to. If I may invoke the holy sayings of the revered masters, ‚Äúnamespaces are a honking great idea‚Äù. To a wizened software engineer, that phrase from the Zen of Python might sound like Python is patting itself on the back for something that basically every modern language does. But for many researchers that are getting their first experience designing a software library, it might seem surprising that I‚Äôm drawing a connection between the pile of files that constitues their code and an abstraction from computer science. If it sounds surprising to you, maybe it‚Äôs because you don‚Äôt (yet) have a good concept map of how namespaces relate to naming your modules and structuring your package.\nSo let me tell you a little bit about that, and how you can build on it to make your code much more accessible. I don‚Äôt claim to have a perfect mental model of Python packages, but at least I have fought enough with my own code, and read enough of others peoples‚Äô code, that I think I can say something useful here. This post contains some things I‚Äôve learned the hard way, to hopefully save you from repeating the mistakes of past me.\nI‚Äôve boiled it down to four tips, that I‚Äôll explain in more detail below.\nHere‚Äôs the high-level version:\nOf course, it goes without saying that these are absolute rules that came to me in a dream where Guido Van Rossum emerged from a burning bush and handed them to me on a freshly-minted PEP. As such, you should never violate them for any reason, unless you feel like it. (Those last two sentences should be written in the sarcasm font.) More seriously, you could call these rules, but there are sometimes good reasons to not follow them to the letter, like we‚Äôll see below.\nOne other thing to say before we get started: I will use some examples here inspired by real life, but namespaces have been changed to protect the innocent. I promise my goal here is not to name shame, but instead to help you make your code as accessible as possible. I also want to note this is not meant to be a whole tutorial, just some pointers on how to pick module names and how to structure your package in a way that makes your code more immediately accessible and more readable. For an introductory tutorial to packages and modules, please see https://realpython.com/python-modules-packages/."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#an-example-of-what-not-to-do",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#an-example-of-what-not-to-do",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "An example of what not to do",
    "text": "An example of what not to do\nHere‚Äôs the scenario: You are really into sharing your research code written in Python. Great! Sharing code just makes sense to you. Your lab is getting on board with this too. You made a GitHub organization for the research group (instead of making an individual profile with the lab name! Please don‚Äôt do that, and make an org page instead, so we can see who‚Äôs in your group and understand who contributes what! For when I want to write you an email thanking you for your work, or ask you to collaborate, or figure out who I want to hire away from academia into the private sector üòà).\nNow everybody in the lab is forking their repos to that org, so you can collaborate and all rely on the same version of the same code. I go to your lab‚Äôs org page and check out one of the repos, and I see something like this.\nelectroymyographytoolkit\n‚îú‚îÄ‚îÄ emg_load_inchan_data_four_channelinkls.py\n‚îú‚îÄ‚îÄ emg_main.py\n‚îú‚îÄ‚îÄ emg_simulate.py\n‚îú‚îÄ‚îÄ emg_solver.py\n‚îú‚îÄ‚îÄ emg_utils.py\n‚îî‚îÄ‚îÄ __init__.py\n\nIn the words of a wise man:\n\nOh No Baby! What Is You Doin???\n\n ‚Äî nicknpattiwhack_"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#what-you-should-do-instead",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#what-you-should-do-instead",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "What you should do instead",
    "text": "What you should do instead\nPlease! Help as many people as possible actually use your code by avoiding naming and package structures like that! Instead you want something like this:\nemgtoolkit\n‚îú‚îÄ‚îÄ load.py\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ simulate.py\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ brute_force.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entropy.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gibson.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ random_walk.py\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shannon.py\n‚îú‚îÄ‚îÄ timestamp.py\n‚îî‚îÄ‚îÄ __init__.py\nThe changes I made above follow the aforementioned four tips. Here‚Äôs they are again, the short version of what you want to do:\n\nGive your packages and modules terse, single-word names whenever possible.\nImport modules internally, instead of importing everything from modules. (You can‚Äôt see this directly in the example above, but I‚Äôll show it below.)\nMake use of sub-packages.\nPrefer modules with very specific names containing single functions over modules with very general names like utils, helpers, or support that contain many functions.\n\nAll of these rules help you make code written with your package more readable from the outside, when someone else uses it from a script. Rules 2,3, and 4 in particular can also help make your code more readable from the inside, when you revisit it after you spent six months in the lab fighting with weird noise from your electrophysiology rig or an IHC protocol or whatever it is that scientists do, I don‚Äôt remember anymore ([laughs in post-academic])."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.pkg_module",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.pkg_module",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Please don‚Äôt name your modules package.pkg_module",
    "text": "Please don‚Äôt name your modules package.pkg_module\nOkay, I will briefly, just for one paragraph, get really ‚Äúopinionated‚Äù. I am not yelling at you. I‚Äôm yelling with you, from the perspective of you as a future user and reader of your own code. (Borrowing a concept from physics while simultaneously breaking its laws, we change our frame of reference and do some time travel so that what you named your modules is no longer a problem for ‚Äúfuture you‚Äù to solve.)\nHere‚Äôs our example package layout again:\nelectroymyographytoolkit\n‚îú‚îÄ‚îÄ emg_load_inchan_data_four_channelinkls.py\n‚îú‚îÄ‚îÄ emg_main.py\n‚îú‚îÄ‚îÄ emg_simulate.py\n‚îú‚îÄ‚îÄ emg_solver.py\n‚îú‚îÄ‚îÄ emg_utils.py\n‚îî‚îÄ‚îÄ __init__.py\n\nyelling:\nLook at this. What is this?! No one wants to type out package.pkg_solver! Why are you making me redundantly type the package name again after I just typed it? Only instead you‚Äôre making me remember and type some abbreviated version of the package name that you dropped some vowels from arbitrarily? And, and you‚Äôre making me type an underscore, that my hand has to go find the shift key for! Every time!!! Yes I know that tab complete exists! This is still too much typing!!! Why do you hate me?\nMore calmly:\nThat might seem like a weirdly specific example to you, but I have seen naming schemes like this more than once (hence, this post). I really do think it has something to do with the way other researchers are thinking about code while writing it and when importing it. They want to import a module from their package and know where it came from, so they put the package name in the module name. I guess? ü§∑ Instead of doing anything like that, just name your package and modules something terse from the get-go, like\nemgtoolkit\n‚îú‚îÄ‚îÄ load.py\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ simulate.py\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ brute_force.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entropy.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gibson.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ random_walk.py\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shannon.py\n‚îú‚îÄ‚îÄ timestamp.py\n‚îî‚îÄ‚îÄ __init__.py\nNow in your scripts you can write out the whole package name, while at the same time having it be more succinct and clear what part of the package‚Äôs namespace you‚Äôre referring to. E.g., emgtoolkit.simulate instead of electromyographytoolkit.emg_simulate. You might have noticed some other things changed in the names, too. Those changes relate to the other tips, that I‚Äôll say more about below."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.incredibly_long_technical_name",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#please-dont-name-your-modules-package.incredibly_long_technical_name",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Please don‚Äôt name your modules package.incredibly_long_technical_name",
    "text": "Please don‚Äôt name your modules package.incredibly_long_technical_name\nThere is also an even more extreme form of verbose module names, that takes the form of:\npkg/\n  incredibly_long_technical_name_or_specific_task\nSometimes this is justified, if it‚Äôs the core functionality of your package and you really need to clearly communicate to everyone in the universe what the package does. E.g., sklearn.model_selection has a very specific meaning, and it‚Äôs hard to capture with an abbreviation, and the library is trying to capture basically several sub-fields of machine learning within this sub-package. I am okay with tab-completing this name just so it‚Äôs clear to all of us what the heck we‚Äôre doing. But pkg.preprocessing_electrophysiological_data is not a great name. Especially if your package only deals with electrophysiological data. You can just say pkg.preprocess, it‚Äôs fine.\n\nInstead, make module names general, and move specifics to function names\nOften these really long module names can be a very specific thing you need to do. Here again you can make things more terse by moving the more specific part to a function name, while keeping the more general part as a module name. For example, instead of\nelectroymyographytoolkit\n‚îú‚îÄ‚îÄ emg_load_inchan_data_four_channels.py\nname the module load, and name a function in that module inchan_data_four_channels, so that you can type out:\n&gt;&gt;&gt; emgtoolkit.load.inchan_data_four_channels()\nYour intention is still obvious. But you rely on attribute access to make that intention clear, while simultaneously more succinct. This also means you have left yourself room later to add other load functions in your module, like\n&gt;&gt;&gt; emgtoolkit.load.inchan_data_accelerometer_channel()\nor whatever. Trust me, there will be a later. Leave space in your namespace."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#import-modules-not-functions-and-classes-for-readability",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#import-modules-not-functions-and-classes-for-readability",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Import modules, not functions and classes, for readability",
    "text": "Import modules, not functions and classes, for readability\nThis is less about naming and more about importing, but it‚Äôs related because I feel like this same anti-pattern arises from someone not understanding what it is that package structure gives you. It gives you a logical grouping that‚Äôs readable not just from the outside but also from the inside. Let me explain.\nI often see something like this in an internal module:\n# inside main.py\nfrom pkg_solver import (\n    EntropySolver,\n    ShannonSolver,\n    GibsonSolver,\n    ...\n    # 10 more lines of class imports from a single module (!)\n    BruteForceSolver,\n    RandomWalkSolver\n)\nLet‚Äôs say this is in emgtoolkit/main.py. Going back to the overall goal of this post, let‚Äôs think about how the import above will affect the namespace of your package, as seen from the outside. if I am using your package, one of the first things I‚Äôm going to do is inspect the content of emgtoolkit.main, e.g.¬†by running dir(emgtoolkit.main) in a Python REPL, since that name signals to me very loudly that you think of this as its main interface or API. With an import statement like the one above, when I tab complete while working with this module, I am going to be faced with a wall of Solver classes that obscures the true function of the module. This is not the solver module! That‚Äôs some other module! If this is a high-level module that you expect me to access as a user, then please avoid polluting it with all these names. One of the ways you can do this is by making use of sub-packages, as I‚Äôll talk about below.\nI want to make a second point here, that is less about making external use of your code readable, and more about making it readable internally, within the code base. I know that right now while you are hacking on the code, you feel like you have all the low-level context about what all the moving parts are doing. But if you want to make life easier for yourself six months from now, and easier for everyone else that has to use your code, write in a way that surfaces that context. Write in a way that makes it much more obvious where all the functions and classes come from, leveraging the logical grouping that you spent so much time boiling down into concise module names.\nPlease, for your future self and everyone else, make the code readable by importing just the module 1, and then referring to those classes (or function or whatever you‚Äôre referring to) via attribute access, i.e.¬†with a dot, like solver.BruteForceSolver. You can get rid of many lines of imports at the top of your module and help yourself out when you are reading many lines deep in your own module, far from those imports, if you instead do this:\n# just import one thing, don't pollute namespace\nfrom . import solvers\n\n...\n# ~150 lines in\n    if solve_strategy == \"entropy\"\n        # ah, this is one of many solvers in this\n        solver = solvers.EntropySolver()\n    elif solve_strategy == \"shannon\"\n        solver = solvers.ShannonSolver()\nOne slight drawback of this terse approach is you can end up shadowing the most intuitive variable name for a class instance with a module that has a similar name. I.e., if I rename my module pkg_solver -&gt; solver then I won‚Äôt be able to do from . import solver at the top and then later also say solver = solver.EntropySolver(), because the variable name solver representing my class instance will clobber the name in the namespace that represents my solver module. This will cause Python‚Äôs head to explode (and yours). In this case I prefer to either use an absolute import internally, import pkg.solver, or to alias internally, e.g., from . import solver as solver_classes, so that an external user still can write something simple like pkg.solver.\n{:footnotes} *"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#you-should-know-sub-packages-exist",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#you-should-know-sub-packages-exist",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "You should know sub-packages exist",
    "text": "You should know sub-packages exist\nAgain, this is less about naming, and more about structuring internals. But it falls under the same category of ‚Äúthing I see that tells me you might not yet have a mental model of how to organize your code to make it easier for you to maintain in the long run‚Äù.\nYou should know (if you don‚Äôt already) that you can make a sub-package inside your package. You do this the same way you make the package itself, by adding the magical __init__.py file that tells Python ‚Äúthis directory is a package‚Äù.\nHere we add a solvers sub-package to the emgtoolkit package from our example.\nemgtoolkit\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îî‚îÄ‚îÄ __init__.py\nHere is an example in the Python docs on modules: https://docs.python.org/3/tutorial/modules.html#packages\nGoing back to our example from above, we can refactor our (presumably gigantic) solver module into a handful of modules inside the solver sub-package:\nemgtoolkit\n‚îú‚îÄ‚îÄ load.py\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ simulate.py\n‚îú‚îÄ‚îÄ solvers\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ brute_force.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entropy.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gibson.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ random_walk.py\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shannon.py\n‚îú‚îÄ‚îÄ timestamp.py\n‚îî‚îÄ‚îÄ __init__.py\nThen you can use imports so that, from the perspective of the user, they have access to the same modules with classes, functions, etc., that they had before. You do this by importing all the classes from each module in the sub-package inside the __init__.py of that sub-package.\n\"\"\"solver sub-package\"\"\"\n# this is __init__.py\nfrom .entropy_solver import EntropySolver\nfrom .shannon_solver ShannonSolver\nfrom .gibson_solver GibsonSolver\n...\nThis kind of looks like the thing I told you to not do above. But the difference here is that you are importing inside the __init__.py file, where (ideally) you are not hiding any functions; instead you are just doing some boring boilerplate imports here to make your life easier somewhere else. This lets you be more intentional about your API too. You can have some helper functions inside the sub-package modules that users don‚Äôt really need. To broadcast to the world the stuff you think people need, you import just that stuff inside your sub-package __init__.py\n\nPython doesn‚Äôt have a concept of ‚Äúpublic and private members of objects‚Äù, as languages like Java do, so there‚Äôs no (good) way for you to absolutely prevent someone from importing and accessing things. Instead Python follows the principle of ‚Äúwe‚Äôre all adults here‚Äù, and uses some conventions to indicate things like private and internal functions. See the section of PEP8 on naming, in particular, where it talks about _single_leading_underscore as a weak ‚Äúinternal use‚Äù indicator.\n\nThe other advantage of breaking code up into many modules within a subpackage, from your perspective as a maintainer, is that you can easily focus on one little chunk of code at a time. I promise that in the long run, this will help you, especially when you need to context switch and work on multiple things at once. Especially if there‚Äôs some helper functions and you‚Äôre not having to scroll or jump around through 3000 lines of code to find them."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#finally-dont-name-a-module-package.utils-or-package.utilities",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#finally-dont-name-a-module-package.utils-or-package.utilities",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Finally, don‚Äôt name a module package.utils or package.utilities",
    "text": "Finally, don‚Äôt name a module package.utils or package.utilities\nSomeone even more jaded than me has already said this: https://breadcrumbscollector.tech/stop-naming-your-python-modules-utils/\nThe basic idea is that the concept of utilities is so nebulous that more and more things will end up crammed into this module, that are less and less related to each other. This is especially likely if multiple people are developing a package, and they are tempted by the name utilities to add just one more helper or validation function inside that (now gigantic) module when trying to add a new feature.\nHold on, friend. Take a step back, take a deep breath. It‚Äôs okay to add a module with just a single function. You can just have a module named timestamp with only one function get_timestamp, and have it be only 10 lines. Please believe me, it will make the codebase easier to read, it will make internal usage of the function easier to read, it will make it easier to write quick unit tests. You do not want to hold 500 lines of utils in your head when you‚Äôre trying to track down a bug. If you don‚Äôt like that your top-level namespace gets cluttered by these little modules, than pull out our sub-package trick from above to push those modules down a level.\nSo that‚Äôs me saying what that other blog post said, after I said they already said it. All I want to add here is that the same logic from above applies: you want people to use your package. So give the modules very specific names so people know exactly what everything is doing. It will help your potential users and it will help future you."
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#take-homes",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#take-homes",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Take-homes",
    "text": "Take-homes\nAt the risk of repeating myself, let me tell you again why you‚Äôd want to take these tips to heart. You want people to use your library that you‚Äôre sharing with the world. It‚Äôs amazing; people can go onto the internet and just use the tools you put all that effort into! As a researcher, this is the kind of instant gratification you can‚Äôt get when you are taking on the Herculean task of putting reality into a headlock with an experiment.\nSo make the most of it! Give your Python packages and modules names with just a few letters, and make use of imports and sub-packages to further structure the namespace of your package so that it‚Äôs convenient to work with. This will also benefit you in the long run when you‚Äôre working with your own code.\nSince I‚Äôm writing for research scientists, I will of course end the discussion by claiming that this blog sets the stage for future research. A good question would be, has anybody done any research supporting my claims that these tips will help you and others read and use your code? If I ever finish reading The Programmer‚Äôs Brain, I‚Äôll probably be able to tell you. Stay tuned for another post. üôÇ"
  },
  {
    "objectID": "posts/2022-12-26-four-tips-structuring-research-python/index.html#footnotes",
    "href": "posts/2022-12-26-four-tips-structuring-research-python/index.html#footnotes",
    "title": "Four tips for structuring your research group‚Äôs Python packages",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee similar comments from core Python dev Brett Cannon in this post, https://snarky.ca/if-i-were-designing-imort-from-scratch/ in the section ‚ÄúYou can only import modules‚Äù.‚Ü©Ô∏é"
  }
]